/***************************************************************************************
//
//		Digital Image Processing Libraries (DIPL)
//
//		Various Filters for DIPL
//
//		Copyright	:: TAMAXI CORPORATION
//		Date		:: 2015.04.19
//		CPU			:: **
//		Language	:: C,C++
//		File Name	:: _dip_filt.c
//
***************************************************************************************/

/*//////////////////////////////////////////////////////////////////////////////////////
//		Definitions & Header Files
//////////////////////////////////////////////////////////////////////////////////////*/
/*
#define		BOOSTING
//*/
/*//////////////////////////////////////////
//		Very Basic Header Files
//////////////////////////////////////////*/
#include	"_system.h"
#include	"_define.h"

/*//////////////////////////////////////////
//		Common Header Files
//////////////////////////////////////////*/
#include	"_dip.h"
#include	"_dip_cnst.h"

/*//////////////////////////////////////////////////////////////////////////////////////
//		Macroinstructions
//////////////////////////////////////////////////////////////////////////////////////*/
#define		_DIVIDE( SUM, XX )			((BYTE)((SUM)/ (XX)))
#define		_SHIFT0( SUM, XX )			((BYTE)((SUM)>>(XX)))
#define		_SHIFT1( SUM, Y, P, XX )	((BYTE)((((SUM))    +(Y)*(*(P)))>>(XX)))
#define		_SHIFT2( SUM, K, P, XX )	((BYTE)((((SUM)*(K))+    (*(P)))>>(XX)))
#define		_SHIFT3( SUM, K, Y, P, XX )	((BYTE)((((SUM)*(K))+(Y)*(*(P)))>>(XX)))
#define		_ACPARAM0			( LONG )(       8 )	/* 自動コントラスト補正係数0	  */
#define		_ACPARAM1			( LONG )(   16384 )	/* 自動コントラスト補正係数1	  */
#define		_ACPARAM2			( LONG )(      14 )	/* 自動コントラスト補正係数2	  */

/*//////////////////////////////////////////////////////////////////////////////////////
//		Type Definitions and Symbol Constant Definitions
//////////////////////////////////////////////////////////////////////////////////////*/
typedef	BYTE (*CALC )( LONG, LONG, BYTE *, LONG ) ;
typedef	LONG (*CALCL)( LONG, LONG, LONG *, LONG ) ;
typedef	BYTE (*FUNC )( BYTE *, BYTE ) ;

/*//////////////////////////////////////////////////////////////////////////////////////
//		Constants and Declarations
//////////////////////////////////////////////////////////////////////////////////////*/
static BYTE *MAXALLY ;
static BYTE *MINALLY ;
static BYTE	coef_grad[] = {
//	  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  2,  2,  2,  3,  3,  3,  4,  4,  4,  5,  5,  6,  6,  7,  7,  8,  9,  9, 10, 10, 11, 12, 13, 13, 14, 15, 16, 16, 17, 18, 19, 20, 21, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 41, 42, 43, 44, 45, 46, 47, 49, 50, 51, 52, 54, 55, 56, 57, 59, 60, 61, 63, 64, 65, 67, 68, 69, 71, 72, 73, 75, 76, 78, 79, 81, 82, 83, 85, 86, 88, 89, 91, 92, 94, 95, 97, 98,100,101,103,104,106,108,109,111,112,114,115,117,118,120,121,123,125,126,128,129,131,132,134,135,137,138,140,142,143,145,146,148,149,151,152,154,155,157,158,160,161,163,164,166,167,169,170,172,173,175,176,177,179,180,182,183,185,186,187,189,190,191,193,194,195,197,198,199,201,202,203,204,206,207,208,209,211,212,213,214,215,216,217,219,220,221,222,223,224,225,226,227,228,229,229,230,231,232,233,234,234,235,236,237,237,238,239,240,240,241,241,242,243,243,244,244,245,245,246,246,247,247,248,248,249,249,250,250,250,251,251,251,252,252,252,253,253,253,253,253,253,254,254,254,
	  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  4,  4,  4,  5,  5,  5,  6,  6,  7,  7,  8,  8,  9,  9, 10, 10, 11, 12, 12, 13, 14, 14, 15, 16, 16, 17, 18, 19, 19, 20, 21, 22, 23, 24, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 48, 49, 50, 51, 52, 53, 55, 56, 57, 58, 60, 61, 62, 64, 65, 66, 68, 69, 70, 72, 73, 75, 76, 77, 79, 81, 82, 84, 85, 87, 89, 90, 92, 94, 96, 98, 99,101,103,105,107,109,111,113,115,117,120,123,126,130,133,135,138,140,142,145,147,148,150,152,154,156,157,159,161,162,164,165,167,169,170,172,173,175,176,178,179,181,182,183,185,186,188,189,190,192,193,194,196,197,198,200,201,202,203,205,206,207,208,209,210,212,213,214,215,216,217,218,219,220,221,222,223,224,225,226,226,227,228,229,230,231,231,232,233,234,234,235,236,236,237,238,238,239,240,240,241,241,242,242,243,244,244,245,245,246,246,247,247,247,248,248,249,249,249,250,250,250,251,251,251,252,252,252,252,253,253,253,253,253,253,254,254,254,254,
//	  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  1,  1,  1,  1,  1,  1,  2,  2,  2,  2,  3,  3,  3,  3,  4,  4,  4,  5,  5,  5,  6,  6,  7,  7,  7,  8,  8,  9,  9, 10, 11, 11, 12, 12, 13, 14, 14, 15, 16, 16, 17, 18, 18, 19, 20, 21, 21, 22, 23, 24, 25, 26, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 51, 52, 53, 54, 55, 57, 58, 59, 60, 62, 63, 64, 66, 67, 68, 70, 71, 73, 74, 76, 78, 79, 81, 83, 84, 86, 88, 90, 92, 94, 96, 98,100,102,104,106,108,111,114,117,121,126,131,135,139,141,144,146,149,151,154,156,158,160,162,163,165,167,168,170,172,173,175,176,178,179,181,182,184,185,187,188,190,191,192,194,195,196,198,199,200,201,203,204,205,206,207,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,224,224,225,226,227,228,229,229,230,231,232,232,233,234,234,235,236,236,237,238,238,239,239,240,241,241,242,242,243,243,244,244,245,245,246,246,247,247,247,248,248,249,249,249,250,250,250,251,251,251,251,252,252,252,252,253,253,253,253,253,253,254,254,254,254,254,
	
} ;

/*//////////////////////////////////////////////////////////////////////////////////////
//		Static Functions
//////////////////////////////////////////////////////////////////////////////////////*/
static BYTE			CHK0 ( BYTE *p, BYTE A ){ return ((BYTE)((*p)!=A)) ; }
static BYTE			CHK1 ( BYTE *p, BYTE A ){ return ((BYTE)((*p)==A)) ; }
static BYTE			CHK2 ( BYTE *p, BYTE A ){ return ((BYTE)((*p)> A)) ; }
static BYTE			CHK3 ( BYTE *p, BYTE A ){ return ((BYTE)((*p)< A)) ; }

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Smooth 8-bit line data.
//				   Based on moving average method (3x1-non-weighted).
//--------------------------------------------------------------------------------------
//	Input		 : leng			: length of original data sequence
//				   sub			: pointer of dummy data sequence
//				   seq			: pointer of input/output data sequence
//--------------------------------------------------------------------------------------
//	Output		 : seq			: pointer of input/output data sequence
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2001.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _SMOOTH_LINE_BYTE				( LONG	leng,
									  BYTE	*sub,
									  BYTE	*seq )
{
	LONG	i, X ;

	////////////////////////////////////////
	// Check arguments and set parameters.
	////////////////////////////////////////
	if( (leng<3)||(sub==NULL)||(seq==NULL) ){ return FALSE ; }
	X = (LONG)(leng-1) ;

	////////////////////
	// Just smooth it!
	////////////////////
	sub[0] = (BYTE)((seq[ 0 ]+seq[1])>>1) ;
	for( i=1 ; i<X ; ){
		sub[i] = (BYTE)((seq[i-1]+(seq[i]<<1)+seq[i+1])>>2) ;
		////sub[i] = (BYTE)((5*(seq[i-1]+seq[i+1])+6*seq[i])>>4) ;
		i++ ;
	}
	sub[X] = (BYTE)((seq[X-1]+seq[X])>>1) ;

	///////////////////////////////////////////////////
	// Copy smoothed sequence to the original buffer.
	///////////////////////////////////////////////////
	memcpy( seq, sub, leng*sizeof(BYTE) ) ;

	///////////////////
	// Just return.
	///////////////////
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Smooth 8-bit line data.
//				   Based on moving average method (3x1-non-weighted).
//--------------------------------------------------------------------------------------
//	Input		 : leng			: length of original data sequence
//				   sub			: pointer of dummy data sequence
//				   seq			: pointer of input/output data sequence
//--------------------------------------------------------------------------------------
//	Output		 : seq			: pointer of input/output data sequence
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2001.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _SMOOTH_LINE_LONG				( LONG	leng,
									  LONG	*sub,
									  LONG	*seq )
{
	LONG	i, X ;

	////////////////////////////////////////
	// Check arguments and set parameters.
	////////////////////////////////////////
	if( (leng<3)||(sub==NULL)||(seq==NULL) ){ return FALSE ; }
	X = (LONG)(leng-1) ;

	////////////////////
	// Just smooth it!
	////////////////////
	sub[0] = ((seq[ 0 ]+seq[1])>>1) ;
	for( i=1 ; i<X ; ){
		sub[i] = (seq[i-1]+(seq[i]<<1)+seq[i+1])>>2 ;
		////sub[i] = (5*(seq[i-1]+seq[i+1])+6*seq[i])>>4 ;
		i++ ;
	}
	sub[X] = ((seq[X-1]+seq[X])>>1) ;

	///////////////////////////////////////////////////
	// Copy smoothed sequence to the original buffer.
	///////////////////////////////////////////////////
	memcpy( seq, sub, leng*sizeof(LONG) ) ;

	///////////////////
	// Just return.
	///////////////////
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Smooth 8-bit line data.
//				   Based on moving average method (3x1-non-weighted).
//--------------------------------------------------------------------------------------
//	Input		 : leng			: length of data sequence
//--------------------------------------------------------------------------------------
//	Output		 : pximg		: pointer of data sequence
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2001.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _SMOOTH_LINE_DOUB				( LONG	leng,
									  DOUB	*seq,
									  DOUB	*sub )
{
	LONG	i, X ;

	////////////////////////////////////////
	// Check arguments and set parameters.
	////////////////////////////////////////
	if( (leng<3)||(sub==NULL)||(seq==NULL) ){ return FALSE ; }
	X = (LONG)(leng-1) ;

	////////////////////
	// Just smooth it!
	////////////////////
	sub[0] = ((seq[ 0 ]+seq[1])/2.0) ;
	for( i=1 ; i<X ; ){
		sub[i] = (seq[i-1]+(seq[i]*2.0)+seq[i+1])/4.0 ;
		////sub[i] = (5.0*(seq[i-1]+seq[i+1])+6.0*seq[i])/16.0 ;
		i++ ;
	}
	sub[X] = ((seq[X-1]+seq[X])/2.0) ;

	///////////////////////////////////////////////////
	// Copy smoothed sequence to the original buffer.
	///////////////////////////////////////////////////
	memcpy( seq, sub, leng*sizeof(LONG) ) ;

	///////////////////
	// Just return.
	///////////////////
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : GRADIENT filter.
//--------------------------------------------------------------------------------------
//	Input		 : type			: processing type
//				   shft			: filter parameter
//				   ofst			: filter parameter
//				   thrs			: filter parameter
//				   xsize		: width  of image data
//				   ysize		: height of image data
//				   ycrcb		: original image data sequence
//--------------------------------------------------------------------------------------
//	Output		 : pdxdy		: output image data sequence
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2011.01.11
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _GRADI_FILTER_DXY				( BYTE	type,	// ﾀｲﾌﾟ      (入力)
									  BYTE	shft,	// ｼﾌﾄ       (入力)
									  BYTE	ofst,	// ｵﾌｾｯﾄ     (入力)
									  BYTE	thrs,	// 閾値      (入力)
									  LONG	xsize,	// 横幅      (入力)
									  LONG	ysize,	// 高さ      (入力)
									  BYTE*	GRAY,	// ｸﾞﾚｰ成分  (入力)
									  BYTE*	CDIF,	// 色差成分  (入力)
									  DXDY* dXdY )	// dXdY成分  (出力)
{
	LONG	i, j, wid, hei, siz       ;
	LONG	q, r, s, t, u             ;
	BYTE	*gray, *g0, *g1, *g2, *g3 ;
	BYTE	*cdif, *c0, *c1, *c2, *c3 ;  
	DXDY	*dxdy, *d0                ;

	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// 変数初期化
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	wid  = xsize-2                    ;
	hei  = ysize-2                    ;
	siz  = xsize*ysize                ;
	gray = GRAY+xsize+1               ;
	cdif = CDIF+xsize+1               ;
	dxdy = dXdY+xsize+1               ;
	g0   = gray    -1                 ;
	g2   = gray    +1                 ;
	g1   = gray-xsize                 ;
	g3   = gray+xsize                 ;
	c0   = cdif    -1                 ;
	c2   = cdif    +1                 ;
	c1   = cdif-xsize                 ;
	c3   = cdif+xsize                 ;
	d0   = dxdy                       ;

	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// GRADIENT filter
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	if     ( type==0 ){ // 辞書用(ﾉｰﾏﾙ) 色差成分は見ていない!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		j    = hei                    ;
		while( j-- ){
			i  = wid                  ;
			while( i-- ){
				////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////
				q      = (*g2 - *g0)                                ; // ｸﾞﾚｰ成分 普通
				r      = (*g3 - *g1)                                ; // ｸﾞﾚｰ成分 普通
				#ifndef	BOOSTING
				d0->dx = (BYTE)((q>>shft)+ofst-(q>>31))             ; // 0~254
				d0->dy = (BYTE)((r>>shft)+ofst-(r>>31))             ; // 0~254
				#else
				d0->dx = coef_grad[((q>>shft)+ofst-(q>>31))]        ; // 0~254
				d0->dy = coef_grad[((r>>shft)+ofst-(r>>31))]        ; // 0~254
				#endif//BOOSTING
				////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////
				(g0++,g1++,g2++,g3++,c0++,c1++,c2++,c3++,d0++)      ;
			}
			(g0+=2,g1+=2,g2+=2,g3+=2,c0+=2,c1+=2,c2+=2,c3+=2,d0+=2) ;
		}
	}
	else if( type==1 ){ // 認識用(ﾉｰﾏﾙ)
		j    = hei                    ;
		while( j-- ){
			i  = wid                  ;
			while( i-- ){
				////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////
				u      = (((*c0-thrs)^(*c2-thrs))>>31)|(((*c1-thrs)^(*c3-thrs))>>31) ; // 大小判定
				if( u ){
					s      = (*c2 - *c0)                                             ; // 色差成分
					t      = (*c3 - *c1)                                             ; // 色差成分
					d0->dx = (BYTE)((s>>shft)+ofst-(s>>31))                          ; // 0~254
					d0->dy = (BYTE)((t>>shft)+ofst-(t>>31))                          ; // 0~254
					c0++                                                             ;
				}
				else   {
					c0++                                                             ;
					q      = (*g2 - *g0)                                             ; // ｸﾞﾚｰ成分 普通
					r      = (*g3 - *g1)                                             ; // ｸﾞﾚｰ成分 普通
					#ifndef	BOOSTING
					d0->dx = (BYTE)((q>>shft)+ofst-(q>>31))                          ; // 0~254
					d0->dy = (BYTE)((r>>shft)+ofst-(r>>31))                          ; // 0~254
					#else
					d0->dx = coef_grad[((q>>shft)+ofst-(q>>31))]                     ; // 0~254
					d0->dy = coef_grad[((r>>shft)+ofst-(r>>31))]                     ; // 0~254
					#endif//BOOSTING
				}
				////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////
				(g0++,g1++,g2++,g3++,/*c0++,*/ c1++,c2++,c3++,d0++) ;
			}
			(g0+=2,g1+=2,g2+=2,g3+=2,c0+=2,c1+=2,c2+=2,c3+=2,d0+=2) ;
		}
	}
	else if( type==2 ){ // 認識用(強調)
		j    = hei                    ;
		while( j-- ){
			i  = wid                  ;
			while( i-- ){
				////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////
				u      = (((*c0-thrs)^(*c2-thrs))>>31)|(((*c1-thrs)^(*c3-thrs))>>31) ; // 大小判定
				if( u ){
					s      = (*c2 - *c0)                                             ; // 色差成分
					t      = (*c3 - *c1)                                             ; // 色差成分
					d0->dx = (BYTE)((s>>shft)+ofst-(s>>31))                          ; // 0~254
					d0->dy = (BYTE)((t>>shft)+ofst-(t>>31))                          ; // 0~254
					c0++                                                             ;
				}
				else   {
					c0++                                                             ;
					q      = ((*g2 - *g0) * *c0 )  >> 8                              ; // ｸﾞﾚｰ成分 強調
					r      = ((*g3 - *g1) * *c0 )  >> 8                              ; // ｸﾞﾚｰ成分 強調
					#ifndef	BOOSTING
					d0->dx = (BYTE)((q>>shft)+ofst-(q>>31))                          ; // 0~254
					d0->dy = (BYTE)((r>>shft)+ofst-(r>>31))                          ; // 0~254
					#else
					d0->dx = coef_grad[((q>>shft)+ofst-(q>>31))]                     ; // 0~254
					d0->dy = coef_grad[((r>>shft)+ofst-(r>>31))]                     ; // 0~254
					#endif//BOOSTING
				}
				////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////
				(g0++,g1++,g2++,g3++,/*c0++,*/ c1++,c2++,c3++,d0++) ;
			}
			(g0+=2,g1+=2,g2+=2,g3+=2,c0+=2,c1+=2,c2+=2,c3+=2,d0+=2) ;
		}
	}
	else return FALSE ;
	
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Return (TRUE).
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : GRADIENT filter.
//--------------------------------------------------------------------------------------
//	Input		 : param		: filter parameter
//				   xsize		: width  of image data
//				   ysize		: height of image data
//				   pxOrg		: original image data sequence
//--------------------------------------------------------------------------------------
//	Output		 : pxPrc		: output image data sequence
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2001.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _GRADI_FILTER_GRY				( BYTE param,
									  LONG xsize,
									  LONG ysize,
									  BYTE *pxOrg,
									  BYTE *pxPrc )
{
	LONG	i, j, wid, hei     ;
	LONG	dX, dY, q, r, s    ;
	BYTE	*Org, *p0          ;
	BYTE	sft0, sft1, ofs    ;
	BYTE	*s0, *s1, *s2, *s3 ;

	////////////////////////////////////////
	// Check arguments and set parameters.
	////////////////////////////////////////
	memset( pxPrc, 0, xsize*ysize ) ; // 周囲だけでよいはず!?
	param = 0 ; // 警告対策

	/////////////////////
	// Sobel-filtering.
	/////////////////////
	wid  = xsize-2       ;
	hei  = ysize-2       ;
	Org  = pxOrg+xsize+1 ; 
	p0   = pxPrc+xsize+1 ;
	s0   = Org        -1 ;
	s1   = Org        +1 ;
	s2   = Org    -xsize ;
	s3   = Org    +xsize ;
	/*
	sft0 =  4            ;
	sft1 =  5            ;
	ofs  = 15            ;
	//*/
	///*
	sft0 =  3            ;
	sft1 =  6            ;
	ofs  = 31            ;
	//*/
	j    = hei           ;
	while( j-- ){
		i  = wid         ;
		while( i-- ){
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			q   = *s0-*s1                       ;
			r   = *s2-*s3                       ;
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			#if 1
			dX  = (q>>sft0) + ofs - (q>>31)     ;
			dY  = (r>>sft0) + ofs - (r>>31)     ;
			s   = (dY<<sft1)+dX                 ;
			*p0 = (BYTE)GRADIENT_MAG[s]         ;
			#else
			s   = (LONG)sqrt(((DOUB)(q*q+r*r))) ;
			if( s>255 ) s=255                   ;
			*p0 = (BYTE)s                       ;
			#endif
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			(s0++,s1++,s2++,s3++,p0++)  ;
		}
		(s0+=2,s1+=2,s2+=2,s3+=2,p0+=2) ;
	}
	///////////////////
	// Return (TRUE).
	///////////////////
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : SOBEL filter.
//--------------------------------------------------------------------------------------
//	Input		 : param		: filter parameter
//				   xsize		: width  of image data
//				   ysize		: height of image data
//				   pxOrg		: original image data sequence
//--------------------------------------------------------------------------------------
//	Output		 : pxPrc		: output image data sequence
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2001.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _SOBEL_FILTER_GRY				( BYTE param,
									  LONG xsize,
									  LONG ysize,
									  BYTE *pxOrg,
									  BYTE *pxPrc )
{
	LONG	i, j, wid, hei     ;
	LONG	P, Q, p, q, r, s   ;
	BYTE	*Org, *p0, *p1     ;
	BYTE	*s1, *s2, *s3, *s4 ;
	BYTE	*s5, *s6, *s7, *s8 ;

	////////////////////////////////////////
	// Check arguments and set parameters.
	////////////////////////////////////////
	memset( pxPrc, 0 , xsize*ysize ) ;
	r = 1 ; // 0:PREWITT,1:SOBEL

	/////////////////////
	// Sobel-filtering.
	/////////////////////
	wid = xsize-2       ;
	hei = ysize-2       ;
	Org = pxOrg+xsize+1 ; 
	p0  = pxPrc+xsize+1 ;
	s1  = Org  -xsize-1 ;
	s2  = Org  -xsize   ;
	s3  = Org  -xsize+1 ;
	s4  = Org        -1 ;
	s5  = Org        +1 ;
	s6  = Org  +xsize-1 ;
	s7  = Org  +xsize   ;
	s8  = Org  +xsize+1 ;
	for( j=0 ; j<hei ; j++ ){
		p1 = p0  ;
		i  = wid ;
		while( i-- ){ //for( i=0 ; i<wid ; i++ ){
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			P = (*s1)-(*s3)+((*s4)<<r)-((*s5)<<r)+(*s6)-(*s8) ;
			Q = (*s1)+((*s2)<<r)+(*s3)-(*s6)-((*s7)<<r)-(*s8) ;
			#if 1
			p = P>>31                                         ;
			q = Q>>31                                         ;
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			p = ((P^p)-p)                                     ;
			q = ((Q^q)-q)                                     ;
			s = p-q                                           ;
			p = (p-(s&(s>>31)))>>param                        ;
			*(p1++) = (BYTE)(p|((255-p)>>31))                 ;
			#else
			s = (LONG)sqrt( ((DOUB)(P*P+Q*Q)) )               ;
			s = s>>2                                          ;
			if( s>255 ) s=255                                 ;
			*(p1++) = (BYTE)s                                 ;
			#endif
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			(s1++,s2++,s3++,s4++,s5++,s6++,s7++,s8++)         ;
		}
		(s1+=2,s2+=2,s3+=2,s4+=2,s5+=2,s6+=2,s7+=2,s8+=2,p0+=xsize) ;
	}

	///////////////////
	// Return (TRUE).
	///////////////////
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : SOBEL filter.
//--------------------------------------------------------------------------------------
//	Input		 : param		: filter parameter
//				   xsize		: width  of image data
//				   ysize		: height of image data
//				   pxOrg		: original image data sequence
//--------------------------------------------------------------------------------------
//	Output		 : pxPrc		: output image data sequence
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2001.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _SOBEL_FILTER_GRY2				( BYTE para0  ,
									  BYTE para1  ,
									  LONG xsize  ,
									  LONG ysize  ,
									  BYTE *pxOrg ,
									  BYTE *pxPrc )
{
	LONG	i, j, wid, hei     ;
	LONG	P, Q, p, q, r, s   ;
	BYTE	*Org, *p0, *p1     ;
	BYTE	*s1, *s2, *s3, *s4 ;
	BYTE	*s5, *s6, *s7, *s8 ;

	////////////////////////////////////////
	// Check arguments and set parameters.
	////////////////////////////////////////
	memset( pxPrc, 0 , xsize*ysize ) ;
	r = 1 ; // 0:PREWITT,1:SOBEL

	/////////////////////
	// Sobel-filtering.
	/////////////////////
	wid = xsize-2       ;
	hei = ysize-2       ;
	Org = pxOrg+xsize+1 ; 
	p0  = pxPrc+xsize+1-xsize ;
	s1  = Org  -xsize-1 ;
	s2  = Org  -xsize   ;
	s3  = Org  -xsize+1 ;
	s4  = Org        -1-xsize ;
	s5  = Org        +1-xsize ;
	s6  = Org  +xsize-1-xsize ;
	s7  = Org  +xsize   ;
	s8  = Org  +xsize+1-xsize ;
	/////////////////////
	//
	//  s1  s2  s3
	//  s4      s5
	//  s6  s7  s8
	//
	/////////////////////


	p1 = p0  ;
	i  = wid ;
	while( i-- ){ //for( i=0 ; i<wid ; i++ ){
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		P = ((*s4)<<r)-((*s5)<<r)+(*s6<<1)-(*s8<<1) ;
		////Q = (*s1)+((*s2)<<r)+(*s3)-(*s6)-((*s7)<<r)-(*s8) ;
		#if 1
		p = P>>31                                         ;
		////q = Q>>31                                         ;
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		p = ((P^p)-p)                                     ;
		////q = ((Q^q)-q)                                     ;
		////s = p-q                                           ;
		////p = (p-(s&(s>>31)))>>para0                        ;
		p >>= para0                                       ;
		*(p1++) = (BYTE)(p|((255-p)>>31))                 ;
		#else
		s = (LONG)sqrt( ((DOUB)(P*P+Q*Q)) )               ;
		s = s>>2                                          ;
		if( s>255 ) s=255                                 ;
		*(p1++) = (BYTE)s                                 ;
		#endif
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		(s4++,s5++,s6++,s8++) ;
	}
	(s4+=2,s5+=2,s6+=2,s8+=2,p0+=xsize) ;


	for( j=0 ; j<hei ; j++ ){
		p1 = p0  ;
		i  = wid ;
		while( i-- ){ //for( i=0 ; i<wid ; i++ ){
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			P = (*s1)-(*s3)+((*s4)<<r)-((*s5)<<r)+(*s6)-(*s8) ;
			////Q = (*s1)+((*s2)<<r)+(*s3)-(*s6)-((*s7)<<r)-(*s8) ;
			#if 1
			p = P>>31                                         ;
			////q = Q>>31                                         ;
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			p = ((P^p)-p)                                     ;
			////q = ((Q^q)-q)                                     ;
			////s = p-q                                           ;
			////p = (p-(s&(s>>31)))>>para0                        ;
			p >>= para0                                       ;
			*(p1++) = (BYTE)( p |((255-p)>>31) )              ;
			#else
			s = (LONG)sqrt( ((DOUB)(P*P+Q*Q)) )               ;
			s = s>>2                                          ;
			if( s>255 ) s=255                                 ;
			*(p1++) = (BYTE)s                                 ;
			#endif
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			(s1++,/*s2++,*/s3++,s4++,s5++,s6++,/*s7++,*/s8++) ;
		}
		(s1+=2,/*s2+=2,*/s3+=2,s4+=2,s5+=2,s6+=2,/*s7+=2,*/s8+=2,p0+=xsize) ;
	}


	p1 = p0  ;
	i  = wid ;
	while( i-- ){ //for( i=0 ; i<wid ; i++ ){
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		P = ((*s4)<<r)-((*s5)<<r)+(*s1<<1)-(*s3<<1) ;
		////Q = (*s1)+((*s2)<<r)+(*s3)-(*s6)-((*s7)<<r)-(*s8) ;
		#if 1
		p = P>>31                                         ;
		////q = Q>>31                                         ;
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		p = ((P^p)-p)                                     ;
		////q = ((Q^q)-q)                                     ;
		////s = p-q                                           ;
		////p = (p-(s&(s>>31)))>>para0                        ;
		p >>= para0                                       ;
		*(p1++) = (BYTE)(p|((255-p)>>31))                 ;
		#else
		s = (LONG)sqrt( ((DOUB)(P*P+Q*Q)) )               ;
		s = s>>2                                          ;
		if( s>255 ) s=255                                 ;
		*(p1++) = (BYTE)s                                 ;
		#endif
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		(s4++,s5++,s1++,s3++) ;
	}

	///////////////////
	// Return (TRUE).
	///////////////////
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : SOBEL filter. 横方向のみ微分ﾌｨﾙﾀ x 2ﾊﾟﾀｰﾝ 
//--------------------------------------------------------------------------------------
//	Input		 : param		: filter parameter
//				   xsize		: width  of image data
//				   ysize		: height of image data
//				   pxOrg		: original image data sequence
//--------------------------------------------------------------------------------------
//	Output		 : pxPr0		: output image data sequence 0
//				   pxPr1		: output image data sequence 1
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2001.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _SOBEL_FILTER_GRY3				( BYTE para0  ,
									  BYTE para1  ,
									  LONG xsize  ,
									  LONG ysize  ,
									  BYTE *pxOrg ,
									  BYTE *pxPr0 ,
									  BYTE *pxPr1 )
{
	LONG	i, j, wid, hei      ;
	LONG	P, Q, R, p, q, r, s ;
	BYTE	*Org                ;
	BYTE	*p0, *p1, *q0, *q1  ;
	BYTE	*s1, *s2, *s3, *s4  ;
	BYTE	*s5, *s6, *s7, *s8  ;

	////////////////////////////////////////
	// Check arguments and set parameters.
	////////////////////////////////////////
	memset( pxPr0, 0 , xsize*ysize ) ;
	memset( pxPr1, 0 , xsize*ysize ) ;
	r = 1                            ; // 0:PREWITT,1:SOBEL

	/////////////////////
	// Sobel-filtering.
	/////////////////////
	wid = xsize-2             ;
	hei = ysize-2             ;
	Org = pxOrg+xsize+1       ; 
	p0  = pxPr0+xsize+1-xsize ;
	q0  = pxPr1+xsize+1-xsize ;
	s1  = Org  -xsize-1       ;
	s2  = Org  -xsize         ;
	s3  = Org  -xsize+1       ;
	s4  = Org        -1-xsize ;
	s5  = Org        +1-xsize ;
	s6  = Org  +xsize-1-xsize ;
	s7  = Org  +xsize         ;
	s8  = Org  +xsize+1-xsize ;
	/////////////////////
	//
	//  s1  s2  s3
	//  s4      s5
	//  s6  s7  s8
	//
	/////////////////////


	p1 = p0  ;
	q1 = q0  ;
	i  = wid ;
	while( i-- ){ //for( i=0 ; i<wid ; i++ ){
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		R = ((*s4)<<r)-((*s5)<<r)+(*s6<<1)-(*s8<<1)       ;
		#if 1
		p = R>>31                                         ;

		P   = (~p) & (+R) ; // R<0 なら P= 0
		P >>= para0       ;
		Q   = ( p) & (-R) ; // R<0 なら Q=-R
		Q >>= para0       ;

		*(p1++) = (BYTE)(P|((255-P)>>31))                 ;
		*(q1++) = (BYTE)(Q|((255-Q)>>31))                 ;
		#else
		s = (LONG)sqrt( ((DOUB)(P*P+Q*Q)) )               ;
		s = s>>2                                          ;
		if( s>255 ) s=255                                 ;
		*(p1++) = (BYTE)s                                 ;
		#endif
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		(s4++,s5++,s6++,s8++) ;
	}
	(s4+=2,s5+=2,s6+=2,s8+=2,p0+=xsize,q0+=xsize) ;


	for( j=0 ; j<hei ; j++ ){
		p1 = p0  ;
		q1 = q0  ;
		i  = wid ;
		while( i-- ){ //for( i=0 ; i<wid ; i++ ){
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			//
			//  s1  s2  s3
			//  s4      s5
			//  s6  s7  s8
			//
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			R = (*s1)-(*s3)+((*s4)<<r)-((*s5)<<r)+(*s6)-(*s8) ;
			#if 1
			p = R>>31                                         ;

			P   = (~p) & (+R) ; // R<0 なら P= 0
			P >>= para0       ;
			Q   = ( p) & (-R) ; // R<0 なら Q=-R
			Q >>= para0       ;

			*(p1++) = (BYTE)(P|((255-P)>>31))                 ;
			*(q1++) = (BYTE)(Q|((255-Q)>>31))                 ;

			#else
			s = (LONG)sqrt( ((DOUB)(P*P+Q*Q)) )               ;
			s = s>>2                                          ;
			if( s>255 ) s=255                                 ;
			*(p1++) = (BYTE)s                                 ;
			#endif
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			(s1++,/*s2++,*/s3++,s4++,s5++,s6++,/*s7++,*/s8++) ;
		}
		(s1+=2,/*s2+=2,*/s3+=2,s4+=2,s5+=2,s6+=2,/*s7+=2,*/s8+=2,p0+=xsize,q0+=xsize) ;
	}


	p1 = p0  ;
	q1 = q0  ;
	i  = wid ;
	while( i-- ){ //for( i=0 ; i<wid ; i++ ){
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		R = ((*s4)<<r)-((*s5)<<r)+(*s1<<1)-(*s3<<1)       ;
		#if 1
		p = R>>31                                         ;

		P   = (~p) & (+R) ; // R<0 なら P= 0
		P >>= para0       ;
		Q   = ( p) & (-R) ; // R<0 なら Q=-R
		Q >>= para0       ;

		*(p1++) = (BYTE)(P|((255-P)>>31))                 ;
		*(q1++) = (BYTE)(Q|((255-Q)>>31))                 ;
		#else
		s = (LONG)sqrt( ((DOUB)(P*P+Q*Q)) )               ;
		s = s>>2                                          ;
		if( s>255 ) s=255                                 ;
		*(p1++) = (BYTE)s                                 ;
		#endif
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		///////////////////////////////////////////////////
		(s4++,s5++,s1++,s3++) ;
	}

	///////////////////
	// Return (TRUE).
	///////////////////
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Sobel filter.
//--------------------------------------------------------------------------------------
//	Input		 : param		: 
//				   xsize		: width  of image data
//				   ysize		: height of image data
//				   pxOrg		: original image data sequence
//--------------------------------------------------------------------------------------
//	Output		 : pxPrc		: output image data sequence
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2001.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _SOBEL_FILTER_RGB				( BYTE param,
									  LONG xsize,
									  LONG ysize,
									  RGBZ *pcOrg,
									  BYTE *pxPrc )
{
	LONG	i, j, wid, hei     ;
	LONG	P, Q, p, q         ;
	LONG	R, S, r, s         ;
	LONG	T, U, t, u         ;
	BYTE	*p0, *p1           ;
	RGBZ	*Org               ;
	RGBZ	*s1, *s2, *s3, *s4 ;
	RGBZ	*s5, *s6, *s7, *s8 ;

	////////////////////////////////////////
	// Check arguments and set parameters.
	////////////////////////////////////////
	memset( pxPrc, 0 , xsize*ysize ) ;

	/////////////////////
	// Sobel-filtering.
	/////////////////////
	wid = xsize-2       ;
	hei = ysize-2       ;
	Org = pcOrg+xsize+1 ; 
	p0  = pxPrc+xsize+1 ;
	s1  = Org-xsize-1   ;
	s2  = Org-xsize     ;
	s3  = Org-xsize+1   ;
	s4  = Org      -1   ;
	s5  = Org      +1   ;
	s6  = Org+xsize-1   ;
	s7  = Org+xsize     ;
	s8  = Org+xsize+1   ;
	for( j=0 ; j<hei ; j++ ){
		p1 = p0  ;
		i  = wid ;
		while( i-- ){ //for( i=0 ; i<wid ; i++ ){
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			P = (s1->B)-(s3->B)+((s4->B)<<1)-((s5->B)<<1)+(s6->B)-(s8->B) ;
			R = (s1->G)-(s3->G)+((s4->G)<<1)-((s5->G)<<1)+(s6->G)-(s8->G) ;
			T = (s1->R)-(s3->R)+((s4->R)<<1)-((s5->R)<<1)+(s6->R)-(s8->R) ;
				
			Q = (s1->B)+((s2->B)<<1)+(s3->B)-(s6->B)-((s7->B)<<1)-(s8->B) ;
			S = (s1->G)+((s2->G)<<1)+(s3->G)-(s6->G)-((s7->G)<<1)-(s8->G) ;
			U = (s1->R)+((s2->R)<<1)+(s3->R)-(s6->R)-((s7->R)<<1)-(s8->R) ;
			
			p = P>>31                                         ;
			r = R>>31                                         ;
			t = T>>31                                         ;
			
			q = Q>>31                                         ;
			s = S>>31                                         ;
			u = U>>31                                         ;
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			p = (((P^p)-p)+((Q^q)-q)+((R^r)-r)+((S^s)-s)+((T^t)-t)+((U^u)-u))>>param ;
			q = (255-p)>>31                                   ;
			*(p1++) = (BYTE)((q&255)|((~q)&p))                ;
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			(s1++,s2++,s3++,s4++,s5++,s6++,s7++,s8++)         ;
		}
		(s1+=2,s2+=2,s3+=2,s4+=2,s5+=2,s6+=2,s7+=2,s8+=2,p0+=xsize) ;
	}

	///////////////////
	// Return (TRUE).
	///////////////////
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Sobel filter.
//--------------------------------------------------------------------------------------
//	Input		 : param		: 
//				   xsize		: width  of image data
//				   ysize		: height of image data
//				   pxOrg		: original image data sequence
//--------------------------------------------------------------------------------------
//	Output		 : pxPrc		: output image data sequence
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2001.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _SOBEL_FILTER_RGB2				( BYTE para0, // ｼﾌﾄ数
									  BYTE para1, // 0:横ｴｯｼﾞ,1:縦ｴｯｼﾞ
									  BYTE para2, // 0:B強調 ,1:G強調, 2:R強調
									  LONG xsize,
									  LONG ysize,
									  RGBZ *pcOrg,
									  BYTE *pxPrc )
{
	LONG	i, j, wid, hei     ;
	LONG	P, Q, p, q         ;
	LONG	R, S, r, s         ;
	LONG	T, U, t, u         ;
	BYTE	*p0, *p1           ;
	RGBZ	*Org               ;
	RGBZ	*s1, *s2, *s3, *s4 ;
	RGBZ	*s5, *s6, *s7, *s8 ;

	////////////////////////////////////////
	// Check arguments and set parameters.
	////////////////////////////////////////
	memset( pxPrc, 0 , xsize*ysize ) ;


	
	/////////////////////
	// Sobel-filtering.
	/////////////////////
	wid = xsize-2       ;
	hei = ysize-2       ;
	Org = pcOrg+xsize+1 ; 
	p0  = pxPrc+xsize+1 ;
	s1  = Org-xsize-1   ;
	s2  = Org-xsize     ;
	s3  = Org-xsize+1   ;
	s4  = Org      -1   ;
	s5  = Org      +1   ;
	s6  = Org+xsize-1   ;
	s7  = Org+xsize     ;
	s8  = Org+xsize+1   ;
	/////////////////////
	//
	//  s1  s2  s3
	//  s4      s5
	//  s6  s7  s8
	//
	/////////////////////


	switch( para1 ){
		case ( 0 )	:
			break ;
		case ( 1 )	:
			return FALSE ; // 仮
		default     :
			return FALSE ;
	}

	
	
	
	
	
	for( j=0 ; j<hei ; j++ ){
		p1 = p0  ;
		i  = wid ;
		while( i-- ){ //for( i=0 ; i<wid ; i++ ){
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			P = (s1->B)-(s3->B)+((s4->B)<<1)-((s5->B)<<1)+(s6->B)-(s8->B) ; // 横方向
			R = (s1->G)-(s3->G)+((s4->G)<<1)-((s5->G)<<1)+(s6->G)-(s8->G) ; // 横方向
			T = (s1->R)-(s3->R)+((s4->R)<<1)-((s5->R)<<1)+(s6->R)-(s8->R) ; // 横方向
				
			//Q = (s1->B)+((s2->B)<<1)+(s3->B)-(s6->B)-((s7->B)<<1)-(s8->B) ; // 縦方向
			//S = (s1->G)+((s2->G)<<1)+(s3->G)-(s6->G)-((s7->G)<<1)-(s8->G) ; // 縦方向
			//U = (s1->R)+((s2->R)<<1)+(s3->R)-(s6->R)-((s7->R)<<1)-(s8->R) ; // 縦方向
			
			p = P>>31                                         ; // 横方向
			r = R>>31                                         ; // 横方向
			t = T>>31                                         ; // 横方向
			
			//q = Q>>31                                         ; // 縦方向
			//s = S>>31                                         ; // 縦方向
			//u = U>>31                                         ; // 縦方向
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			p = (((P^p)-p)+/*((Q^q)-q)+*/((R^r)-r)+/*((S^s)-s)+*/((T^t)-t)/*+((U^u)-u)*/)>>para0 ;
			q = (255-p)>>31                                   ;
			*(p1++) = (BYTE)((q&255)|((~q)&p))                ;
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			(s1++,/*s2++,*/s3++,s4++,s5++,s6++,/*s7++,*/s8++) ;
		}
		(s1+=2,/*s2+=2,*/s3+=2,s4+=2,s5+=2,s6+=2,/*s7+=2,*/s8+=2,p0+=xsize) ;
	}








	///////////////////
	// Return (TRUE).
	///////////////////
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : PREWITT filter.
//--------------------------------------------------------------------------------------
//	Input		 : param		: filter parameter
//				   xsize		: width  of image data
//				   ysize		: height of image data
//				   pxOrg		: original image data sequence
//--------------------------------------------------------------------------------------
//	Output		 : pxPrc		: output image data sequence
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2001.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _PRWIT_FILTER_GRY				( BYTE param,
									  LONG xsize,
									  LONG ysize,
									  BYTE *pxOrg,
									  BYTE *pxPrc )
{
	LONG	i, j, wid, hei     ;
	LONG	P, Q, p, q, r, s   ;
	BYTE	*Org, *p0, *p1     ;
	BYTE	*s1, *s2, *s3, *s4 ;
	BYTE	*s5, *s6, *s7, *s8 ;

	////////////////////////////////////////
	// Check arguments and set parameters.
	////////////////////////////////////////
	memset( pxPrc, 0 , xsize*ysize ) ;
	r = 0 ; // 0:PREWITT,1:SOBEL

	/////////////////////
	// Sobel-filtering.
	/////////////////////
	wid = xsize-2       ;
	hei = ysize-2       ;
	Org = pxOrg+xsize+1 ; 
	p0  = pxPrc+xsize+1 ;
	s1  = Org  -xsize-1 ;
	s2  = Org  -xsize   ;
	s3  = Org  -xsize+1 ;
	s4  = Org        -1 ;
	s5  = Org        +1 ;
	s6  = Org  +xsize-1 ;
	s7  = Org  +xsize   ;
	s8  = Org  +xsize+1 ;
	for( j=0 ; j<hei ; j++ ){
		p1 = p0  ;
		i  = wid ;
		while( i-- ){ //for( i=0 ; i<wid ; i++ ){
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			P = (*s1)-(*s3)+(*s4)-(*s5)+(*s6)-(*s8)           ;
			Q = (*s1)+(*s2)+(*s3)-(*s6)-(*s7)-(*s8)           ;
			#if 1
			p = P>>31                                         ;
			q = Q>>31                                         ;
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			p = ((P^p)-p)                                     ;
			q = ((Q^q)-q)                                     ;
			s = p-q                                           ;
			p = (p-(s&(s>>31)))>>param                        ;
			*(p1++) = (BYTE)(p|((255-p)>>31))                 ;
			#else
			s = (LONG)sqrt( ((DOUB)(P*P+Q*Q)) )               ;
			s = s>>2                                          ;
			if( s>255 ) s=255                                 ;
			*(p1++) = (BYTE)s                                 ;
			#endif
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			(s1++,s2++,s3++,s4++,s5++,s6++,s7++,s8++)         ;
		}
		(s1+=2,s2+=2,s3+=2,s4+=2,s5+=2,s6+=2,s7+=2,s8+=2,p0+=xsize) ;
	}

	///////////////////
	// Return (TRUE).
	///////////////////
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Fast PREWITT Filter.
//--------------------------------------------------------------------------------------
//	Input		 : param		: filter parameter
//				   xsize		: width  of image data
//				   ysize		: height of image data
//				   pxOrg		: original image data sequence
//--------------------------------------------------------------------------------------
//	Output		 : pxPrc		: output image data sequence
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2001.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _PRWIT_FILTER_GRY_FAST			( BYTE	param ,
									  LONG*	lbuff ,
									  LONG	xsize ,
									  LONG	ysize ,
									  BYTE*	pxOrg ,
									  BYTE*	pxPrc )
{
	LONG		i, j, k, wid, hei, P, Q, p, q, r, *updat       ;
	LONG		*Accy0, *Accy1, *Accy2, *Sumxx                 ;
	LONG		*accy0, *accy1, *accy2, *sumxx                 ;
	LONG*		prc1[3]                                        ;
	LONG*		prc2[3]                                        ;
	LONG		*v0, *v1, *v2, *v3, *w0, *w1                   ;
	BYTE		*p0, *p1, *u0, *u1, *t0, *t1                   ;
	static LONG	part[] = { 2, 0, 1 }                           ;

	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// 周辺塗潰し
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	p0       = pxPrc                                           ;
	i        = xsize                                           ;
	memset( p0, 0, i )                                         ;
	j        = ysize-2                                         ;
	p0       = pxPrc+i                                         ;
	while( j-- ){
		*p0  = 0                                               ;
		p0  += xsize                                           ;
	}
	p0       = pxPrc+xsize*ysize-i                             ;
	memset( p0, 0, i )                                         ;
	j        = ysize-2                                         ;
	p0       = pxPrc+i+xsize-1                                 ;
	while( j-- ){
		*p0  = 0                                               ;
		p0  += xsize                                           ;
	}
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// 変数初期化
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	wid      = xsize - 3                                       ;
	hei      = ysize - 3                                       ;
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	//
	//
	// 最初の3行分について処理
	// 総和sumxx,累計accy0,accy1,accy2を求める
	//
	//
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	Sumxx    = lbuff                                           ;
	Accy0    = prc1[0] = prc2[1] = Sumxx + xsize               ;
	Accy1    = prc1[1] = prc2[2] = Accy0 + xsize               ;
	Accy2    = prc1[2] = prc2[0] = Accy1 + xsize               ;
	accy0    = Accy0                                           ;
	accy1    = Accy1                                           ;
	accy2    = Accy2                                           ;
	p0       = pxOrg                                           ;
	accy0[0] = *(p0++)                                         ;
	for( i=1 ; i<xsize ; i++ ) accy0[i] = *(p0++) + accy0[i-1] ; // 累計 x方向
	accy1[0] = *(p0++)                                         ;
	for( i=1 ; i<xsize ; i++ ) accy1[i] = *(p0++) + accy1[i-1] ; // 累計 x方向
	accy2[0] = *(p0++)                                         ;
	for( i=1 ; i<xsize ; i++ ) accy2[i] = *(p0++) + accy2[i-1] ; // 累計 x方向
	sumxx    = Sumxx                                           ;
	p0       = pxOrg                                           ;
	for( i=0 ; i<xsize ; i++ ){
		p1       = p0                                          ;
		sumxx[i] = 0                                           ;
		for( j=0 ; j<3 ; j++ ){
			sumxx[i] += *p1                                    ; // 総和 y方向
			p1       += xsize                                  ;
		}
		p0++                                                   ;
	}
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// ｽｷｬﾝ & 更新
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	k        = 0                                               ;
	p0       = pxOrg                                           ;
	u0       = pxOrg+xsize*3                                   ;
	t0       = pxPrc+xsize+1                                   ;
	for( j=0 ; j<hei ; j++ ){
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		//
		// dX成分で演算対象になるのは？
		// sumxx[*],sumxx[*+2]
		// dY成分で演算対象になるのは？
		// (0,2)(1,0)(2,1)....
		// prc1[k] と prc2[k] で算出
		//
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		t1   = t0                                              ;
		v0   = prc1[k]+2                                       ;
		v1   = prc2[k]+2                                       ;
		v2   = prc1[k]                                         ;
		v3   = prc2[k]                                         ;
		w0   = sumxx                                           ;
		w1   = sumxx+2                                         ;
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		P    = *v0 - *v1                                       ;
		Q    = P>>31                                           ;
		p    = ((P^Q)-Q)                                       ;
		P    = *w0 - *w1                                       ;
		Q    = P>>31                                           ;
		q    = ((P^Q)-Q)                                       ;
		/*
		r    = p-q                                             ;
		r    = (p-(r&(r>>31)))>>param                          ;
		//*/
		r    = (p+q)>>param                                    ;
		*t1  = (BYTE)(r|((255-r)>>31))                         ; ///////////////////////
		v0++,v1++,w0++,w1++,t1++                               ;
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		i    = wid                                             ;
		while( i-- ){ // for( i=0 ; i<wid ; i++ ){
			P    = (*v0-*v2) - (*v1-*v3)                       ; ///////////////////////
			Q    = P>>31                                       ; ///////////////////////
			p    = ((P^Q)-Q)                                   ; ///////////////////////
			P    = *w0 - *w1                                   ; ///////////////////////
			Q    = P>>31                                       ; ///////////////////////
			q    = ((P^Q)-Q)                                   ; ///////////////////////
			/*
			r    = p-q                                         ;
			r    = (p-(r&(r>>31)))>>param                      ;
			//*/
			r    = (p+q)>>param                                ; ///////////////////////
			*t1  = (BYTE)(r|((255-r)>>31))                     ; ///////////////////////
			v0++,v1++,v2++,v3++,w0++,w1++,t1++                 ; ///////////////////////
		}
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		//
		// ﾊﾞｯﾌｧ更新(3行目から)
		// x方向 sumxx  は毎行
		// y方向 prc1[k]のみ
		//
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		p1       = p0                                          ;
		u1       = u0                                          ;
		v0       = sumxx                                       ;
		i        = xsize                                       ;
		while( i-- ){ // for( i=0 ; i<xsize ; i++ ){
			*(v0++) += ( *(u1++)-*(p1++) )                     ; // 総和 y方向
		}
		updat    = prc1[k]                                     ;
		u1       = u0                                          ;
		v0       =
		v1       = updat                                       ;
		*(v1++)  = *(u1++)                                     ;
		i        = xsize-1                                     ;
		while( i-- ){
			*(v1++)  = *(u1++) + *(v0++)                       ; // 累計 x方向
		}
		p0      += xsize                                       ;
		u0      += xsize                                       ;
		t0      += xsize                                       ;
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		k       ++                                             ;
		k        = ((k-3)>>31)&k                               ;
	}
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	//
	// 最後の行を忘れずに
	// dX成分で演算対象になるのは？
	// sumxx[*],sumxx[*+2]
	// dY成分で演算対象になるのは？
	// (0,2)(1,0)(2,1)....
	// prc1[k] と prc2[k] で算出
	//
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	t1   = t0                                                  ;
	v0   = prc1[k]+2                                           ;
	v1   = prc2[k]+2                                           ;
	v2   = prc1[k]                                             ;
	v3   = prc2[k]                                             ;
	w0   = sumxx                                               ;
	w1   = sumxx+2                                             ;
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	P    = *v0 - *v1                                           ;
	Q    = P>>31                                               ;
	p    = ((P^Q)-Q)                                           ;
	P    = *w0 - *w1                                           ;
	Q    = P>>31                                               ;
	q    = ((P^Q)-Q)                                           ;
	/*
	r    = p-q                                                 ;
	r    = (p-(r&(r>>31)))>>param                              ;
	//*/
	r    = (p+q)>>param                                        ;
	*t1  = (BYTE)(r|((255-r)>>31))                             ; ///////////////////////
	v0++,v1++,w0++,w1++,t1++                                   ;
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	i    = wid                                                 ;
	while( i-- ){ // for( i=0 ; i<wid ; i++ ){
		P    = (*v0-*v2) - (*v1-*v3)                           ; ///////////////////////
		Q    = P>>31                                           ; ///////////////////////
		p    = ((P^Q)-Q)                                       ; ///////////////////////
		P    = *w0 - *w1                                       ; ///////////////////////
		Q    = P>>31                                           ; ///////////////////////
		q    = ((P^Q)-Q)                                       ; ///////////////////////
		/*
		r    = p-q                                             ;
		r    = (p-(r&(r>>31)))>>param                          ;
		//*/
		r    = (p+q)>>param                                    ; ///////////////////////
		*t1  = (BYTE)(r|((255-r)>>31))                         ; ///////////////////////
		v0++,v1++,v2++,v3++,w0++,w1++,t1++                     ; ///////////////////////
	}
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Return (TRUE).
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	return TRUE                                                ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Fast PREWITT Filter with skin color plane.
//--------------------------------------------------------------------------------------
//	Input		 : param		: filter parameter
//				   xsize		: width  of image data
//				   ysize		: height of image data
//				   pxOrg		: original image data sequence
//--------------------------------------------------------------------------------------
//	Output		 : pxPrc		: output image data sequence
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2001.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _PRWIT_FILTER_GRY_SKIN			( BYTE	param ,
									  BYTE	thres ,
									  BYTE	value ,
									  LONG*	lbuff ,
									  LONG	xsize ,
									  LONG	ysize ,
									  BYTE*	pxOrg ,
									  BYTE*	pxSkn ,
									  BYTE*	pxPrc )
{
	LONG		i, j, k, wid, hei, P, Q, p, q, r, s, *updat    ;
	LONG		*Accy0, *Accy1, *Accy2, *Sumxx                 ;
	LONG		*accy0, *accy1, *accy2, *sumxx                 ;
	LONG*		prc1[3]                                        ;
	LONG*		prc2[3]                                        ;
	LONG		*v0, *v1, *v2, *v3, *w0, *w1                   ;
	BYTE		*p0, *p1, *u0, *u1, *t0, *t1                   ;
	BYTE		*s0, *s1, *s2, *s3                             ;
	static LONG	part[] = { 2, 0, 1 }                           ;

	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// 周辺塗潰し
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	p0       = pxPrc                                           ;
	i        = xsize                                           ;
	memset( p0, 0, i )                                         ;
	j        = ysize-2                                         ;
	p0       = pxPrc+i                                         ;
	while( j-- ){
		*p0  = 0                                               ;
		p0  += xsize                                           ;
	}
	p0       = pxPrc+xsize*ysize-i                             ;
	memset( p0, 0, i )                                         ;
	j        = ysize-2                                         ;
	p0       = pxPrc+i+xsize-1                                 ;
	while( j-- ){
		*p0  = 0                                               ;
		p0  += xsize                                           ;
	}
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// 変数初期化
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	wid      = xsize - 3                                       ;
	hei      = ysize - 3                                       ;
	s0       = pxSkn + xsize                                   ;
	s1       = pxSkn + 1                                       ;
	s2       = s0    + 2                                       ;
	s3       = s1    + xsize*2                                 ;
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	//
	//
	// 最初の3行分について処理
	// 総和sumxx,累計accy0,accy1,accy2を求める
	//
	//
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	Sumxx    = lbuff                                           ;
	Accy0    = prc1[0] = prc2[1] = Sumxx + xsize               ;
	Accy1    = prc1[1] = prc2[2] = Accy0 + xsize               ;
	Accy2    = prc1[2] = prc2[0] = Accy1 + xsize               ;
	accy0    = Accy0                                           ;
	accy1    = Accy1                                           ;
	accy2    = Accy2                                           ;
	p0       = pxOrg                                           ;
	accy0[0] = *(p0++)                                         ;
	for( i=1 ; i<xsize ; i++ ) accy0[i] = *(p0++) + accy0[i-1] ; // 累計 x方向
	accy1[0] = *(p0++)                                         ;
	for( i=1 ; i<xsize ; i++ ) accy1[i] = *(p0++) + accy1[i-1] ; // 累計 x方向
	accy2[0] = *(p0++)                                         ;
	for( i=1 ; i<xsize ; i++ ) accy2[i] = *(p0++) + accy2[i-1] ; // 累計 x方向
	sumxx    = Sumxx                                           ;
	p0       = pxOrg                                           ;
	for( i=0 ; i<xsize ; i++ ){
		p1       = p0                                          ;
		sumxx[i] = 0                                           ;
		for( j=0 ; j<3 ; j++ ){
			sumxx[i] += *p1                                    ; // 総和 y方向
			p1       += xsize                                  ;
		}
		p0++                                                   ;
	}
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// ｽｷｬﾝ & 更新
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	k        = 0                                               ;
	p0       = pxOrg                                           ;
	u0       = pxOrg+xsize*3                                   ;
	t0       = pxPrc+xsize+1                                   ;
	for( j=0 ; j<hei ; j++ ){
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		//
		// dX成分で演算対象になるのは？
		// sumxx[*],sumxx[*+2]
		// dY成分で演算対象になるのは？
		// (0,2)(1,0)(2,1)....
		// prc1[k] と prc2[k] で算出
		//
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		t1   = t0                                              ;
		v0   = prc1[k]+2                                       ;
		v1   = prc2[k]+2                                       ;
		v2   = prc1[k]                                         ;
		v3   = prc2[k]                                         ;
		w0   = sumxx                                           ;
		w1   = sumxx+2                                         ;
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		P    = *v0 - *v1                                       ;
		Q    = P>>31                                           ;
		p    = ((P^Q)-Q)                                       ;
		P    = *w0 - *w1                                       ;
		Q    = P>>31                                           ;
		q    = ((P^Q)-Q)                                       ;
		/*
		r    = p-q                                             ;
		r    = (p-(r&(r>>31)))>>param                          ;
		//*/
		//############################################################################//
		//############################################################################//
		//############################################################################//
		//############################################################################//
		s    = (((*s0-thres)^(*s2-thres))>>31)|(((*s1-thres)^(*s3-thres))>>31)      ; // 大小判定
		if( s ){
			*t1  = value                                       ; ///////////////////////
			s0++                                               ; ///////////////////////
		}
		else   {
			s0++                                               ; ///////////////////////
			r    = ((p+q)*(*s0))>> (param)                     ; ///////////////////////
			*t1  = (BYTE)(r|((255-r)>>31))                     ; ///////////////////////
		}
		v0++,v1++,w0++,w1++,t1++                               ; ///////////////////////
		/*s0++, */s1++,s2++,s3++                               ; ///////////////////////
		//############################################################################//
		//############################################################################//
		//############################################################################//
		//############################################################################//
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		i    = wid                                             ;
		while( i-- ){ // for( i=0 ; i<wid ; i++ ){
			P    = (*v0-*v2) - (*v1-*v3)                       ; ///////////////////////
			Q    = P>>31                                       ; ///////////////////////
			p    = ((P^Q)-Q)                                   ; ///////////////////////
			P    = (*w0 - *w1)                                 ; ///////////////////////
			Q    = P>>31                                       ; ///////////////////////
			q    = ((P^Q)-Q)                                   ; ///////////////////////
			/*
			r    = p-q                                         ;
			r    = (p-(r&(r>>31)))>>param                      ;
			//*/
			//########################################################################//
			//########################################################################//
			//########################################################################//
			//########################################################################//
			
			
			s    = (((*s0-thres)^(*s2-thres))>>31)|(((*s1-thres)^(*s3-thres))>>31)  ; // 大小判定
			

			if( s ){
				*t1  = value                                   ; ///////////////////////
				s0++                                           ; ///////////////////////
			}
			else   {
				
				
				

				s0++                                           ; ///////////////////////
				
				if( *s0<thres ) r    = ((p+q)*(*s0))>> (param)                 ; ///////////////////////
				
				else            r    = (p+q)>>1 ;
				
				//r    = ((p+q)*(*s0))>> (param)                 ;
				
				*t1  = (BYTE)(r|((255-r)>>31))                 ; ///////////////////////



			}
			v0++,v1++,v2++,v3++,w0++,w1++,t1++                 ; ///////////////////////
			/*s0++, */s1++,s2++,s3++                           ; ///////////////////////
			//########################################################################//
			//########################################################################//
			//########################################################################//
			//########################################################################//
		}
		s0+=2,s1+=2,s2+=2,s3+=2                                ;
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		//
		// ﾊﾞｯﾌｧ更新(3行目から)
		// x方向 sumxx  は毎行
		// y方向 prc1[k]のみ
		//
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		p1       = p0                                          ;
		u1       = u0                                          ;
		v0       = sumxx                                       ;
		i        = xsize                                       ;
		while( i-- ){ // for( i=0 ; i<xsize ; i++ ){
			*(v0++) += ( *(u1++)-*(p1++) )                     ; // 総和 y方向
		}
		updat    = prc1[k]                                     ;
		u1       = u0                                          ;
		v0       =
		v1       = updat                                       ;
		*(v1++)  = *(u1++)                                     ;
		i        = xsize-1                                     ;
		while( i-- ){
			*(v1++)  = *(u1++) + *(v0++)                       ; // 累計 x方向
		}
		p0      += xsize                                       ;
		u0      += xsize                                       ;
		t0      += xsize                                       ;
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		k       ++                                             ;
		k        = ((k-3)>>31)&k                               ;
	}
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	//
	// 最後の行を忘れずに
	// dX成分で演算対象になるのは？
	// sumxx[*],sumxx[*+2]
	// dY成分で演算対象になるのは？
	// (0,2)(1,0)(2,1)....
	// prc1[k] と prc2[k] で算出
	//
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	t1   = t0                                                  ;
	v0   = prc1[k]+2                                           ;
	v1   = prc2[k]+2                                           ;
	v2   = prc1[k]                                             ;
	v3   = prc2[k]                                             ;
	w0   = sumxx                                               ;
	w1   = sumxx+2                                             ;
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	P    = *v0 - *v1                                           ;
	Q    = P>>31                                               ;
	p    = ((P^Q)-Q)                                           ;
	P    = *w0 - *w1                                           ;
	Q    = P>>31                                               ;
	q    = ((P^Q)-Q)                                           ;
	/*
	r    = p-q                                                 ;
	r    = (p-(r&(r>>31)))>>param                              ;
	//*/
	//################################################################################//
	//################################################################################//
	//################################################################################//
	//################################################################################//
	s    = (((*s0-thres)^(*s2-thres))>>31)|(((*s1-thres)^(*s3-thres))>>31)          ; // 大小判定
	if( s ){
		*t1  = value                                           ; ///////////////////////
		s0++                                                   ; ///////////////////////
	}
	else   {
		s0++                                                   ; ///////////////////////
		r    = ((p+q)*(*s0))>> (param)                         ; ///////////////////////
		*t1  = (BYTE)(r|((255-r)>>31))                         ; ///////////////////////
	}
	v0++,v1++,w0++,w1++,t1++                                   ; ///////////////////////
	/*s0++, */s1++,s2++,s3++                                   ; ///////////////////////
	//################################################################################//
	//################################################################################//
	//################################################################################//
	//################################################################################//
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	i    = wid                                                 ;
	while( i-- ){ // for( i=0 ; i<wid ; i++ ){
		P    = (*v0-*v2) - (*v1-*v3)                           ; ///////////////////////
		Q    = P>>31                                           ; ///////////////////////
		p    = ((P^Q)-Q)                                       ; ///////////////////////
		P    = *w0 - *w1                                       ; ///////////////////////
		Q    = P>>31                                           ; ///////////////////////
		q    = ((P^Q)-Q)                                       ; ///////////////////////
		/*
		r    = p-q                                             ;
		r    = (p-(r&(r>>31)))>>param                          ;
		//*/
		//############################################################################//
		//############################################################################//
		//############################################################################//
		//############################################################################//
		s    = (((*s0-thres)^(*s2-thres))>>31)|(((*s1-thres)^(*s3-thres))>>31)      ; // 大小判定
		if( s ){
			*t1  = value                                       ; ///////////////////////
			s0++                                               ; ///////////////////////
		}
		else   {
			s0++                                               ; ///////////////////////
			r    = ((p+q)*(*s0))>> (param)                     ; ///////////////////////
			*t1  = (BYTE)(r|((255-r)>>31))                     ; ///////////////////////
		}
		v0++,v1++,v2++,v3++,w0++,w1++,t1++                     ; ///////////////////////
		/*s0++, */s1++,s2++,s3++                               ; ///////////////////////
		//############################################################################//
		//############################################################################//
		//############################################################################//
		//############################################################################//
	}
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Return (TRUE).
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	return TRUE                                                ;
}

#if 0
/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Sobel filter.
//--------------------------------------------------------------------------------------
//	Input		 : param		: 
//				   xsize		: width  of image data
//				   ysize		: height of image data
//				   pxOrg		: original image data sequence
//--------------------------------------------------------------------------------------
//	Output		 : pxPrc		: output image data sequence
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2001.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _SOBEL_FILTER_GRY1				( BYTE param,
									  LONG xsize,
									  LONG ysize,
									  BYTE *pxOrg,
									  BYTE *pxPrc )
{
	LONG	i, j, wid, hei     ;
	LONG	P, Q, p, q, r, s   ;
	BYTE	*Org, *p0, *p1     ;
	BYTE	*s1, *s2, *s3, *s4 ;
	BYTE	*s5, *s6, *s7, *s8 ;

	////////////////////////////////////////
	// Check arguments and set parameters.
	////////////////////////////////////////
	memset( pxPrc, 0 , xsize*ysize ) ;
	r = 1 ; // SOBEL
	/*
	r = 0 ; // PREWITT
	//*/

	/////////////////////
	// Sobel-filtering.
	/////////////////////
	wid = xsize-2       ;
	hei = ysize-2       ;
	Org = pxOrg+xsize+1 ; 
	p0  = pxPrc+xsize+1 ;
	s1  = Org  -xsize-1 ;
	s2  = Org  -xsize   ;
	s3  = Org  -xsize+1 ;
	s4  = Org        -1 ;
	s5  = Org        +1 ;
	s6  = Org  +xsize-1 ;
	s7  = Org  +xsize   ;
	s8  = Org  +xsize+1 ;
	for( j=0 ; j<hei ; j++ ){
		p1 = p0  ;
		i  = wid ;
		while( i-- ){ //for( i=0 ; i<wid ; i++ ){
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			P = (*s1)-(*s3)+((*s4)<<r)-((*s5)<<r)+(*s6)-(*s8) ;
			Q = (*s1)+((*s2)<<r)+(*s3)-(*s6)-((*s7)<<r)-(*s8) ;
			#if 1
			p = P>>31                                         ;
			q = Q>>31                                         ;
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			/*
			p = (((P^p)-p)+((Q^q)-q))>>param                  ;
			//*/
			p = ((P^p)-p)     ;
			q = ((Q^q)-q)     ;
			s = p-q           ;
			
			p = (p-(s&(s>>31)))>>param ;

			/*
			q = (p-256)>>31   ; // p>255 => 0, p<=255 => -1
			//*/
			//q = (255-p)>>31   ; // p>255 =>-1, p<=255 =>  0
			
			/*
			*(p1++) = (BYTE)((q&255)|((~q)&p)) ;
			*(p1++) = (BYTE)((q|p)&0xff)       ;
			//*/
			*(p1++) = (BYTE)(p|((255-p)>>31)) ;

			#else
			s = (LONG)sqrt( ((DOUB)(P*P+Q*Q)) ) ;
			s = s>>2 ;
			if( s>255 ) s=255;
			*(p1++) = (BYTE)s ;
			#endif
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			(s1++,s2++,s3++,s4++,s5++,s6++,s7++,s8++)         ;
		}
		(s1+=2,s2+=2,s3+=2,s4+=2,s5+=2,s6+=2,s7+=2,s8+=2,p0+=xsize) ;
	}

	///////////////////
	// Return (TRUE).
	///////////////////
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Sobel filter.
//--------------------------------------------------------------------------------------
//	Input		 : param		: 
//				   xsize		: width  of image data
//				   ysize		: height of image data
//				   pxOrg		: original image data sequence
//--------------------------------------------------------------------------------------
//	Output		 : pxPrc		: output image data sequence
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2001.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _SOBEL_FILTER_GRY2				( BYTE param,
									  LONG xsize,
									  LONG ysize,
									  BYTE *pxOrg,
									  BYTE *pxPrc )
{
	LONG	i, j, wid, hei     ;
	LONG	P, Q, p, q, xsize2 ;
	BYTE	*Org, *p0, *p1     ;
	BYTE	*s1, *s2, *s3, *s4 ;
	BYTE	*s5, *s6, *s7, *s8 ;

	////////////////////////////////////////
	// Check arguments and set parameters.
	////////////////////////////////////////
	memset( pxPrc, 0 , xsize*ysize ) ;

	/////////////////////
	// Sobel-filtering.
	/////////////////////
	wid = xsize-4        ;
	hei = ysize-4        ;
	xsize2 = 2*xsize     ;
	Org = pxOrg+xsize2+2 ; 
	p0  = pxPrc+xsize2+2 ;
	s1  = Org  -xsize2-2 ;
	s2  = Org  -xsize2   ;
	s3  = Org  -xsize2+2 ;
	s4  = Org         -2 ;
	s5  = Org         +2 ;
	s6  = Org  +xsize2-2 ;
	s7  = Org  +xsize2   ;
	s8  = Org  +xsize2+2 ;
	for( j=0 ; j<hei ; j++ ){
		p1 = p0  ;
		i  = wid ;
		while( i-- ){ //for( i=0 ; i<wid ; i++ ){
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			P = (*s1)-(*s3)+((*s4)<<1)-((*s5)<<1)+(*s6)-(*s8) ;
			Q = (*s1)+((*s2)<<1)+(*s3)-(*s6)-((*s7)<<1)-(*s8) ;
			p = P>>31                                         ;
			q = Q>>31                                         ;
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			p = (((P^p)-p)+((Q^q)-q))>>param                  ;
			q = (255-p)>>31                                   ;
			*(p1++) = (BYTE)((q&255)|((~q)&p))                ;
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			///////////////////////////////////////////////////
			(s1++,s2++,s3++,s4++,s5++,s6++,s7++,s8++)         ;
		}
		(s1+=4,s2+=4,s3+=4,s4+=4,s5+=4,s6+=4,s7+=4,s8+=4,p0+=xsize) ;
	}

	///////////////////
	// Return (TRUE).
	///////////////////
	return TRUE ;
}
#endif
/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Smooth 8-bit line data.
//				   Based on moving average method.
//--------------------------------------------------------------------------------------
//	Input		 : prctype		: smoothing type
//								  0: averaged by division  (SUM/(K*L))
//								  1: averaged by bit-shift (SUM>>xxxx)
//								  2: averaged by bit-shift, weighted
//									 (SUM+Y*P)>>xxxx(P:pixel value), L+Y = 2^xxxx
//				   memtype		: memory type
//								  0: memory allocated in advance
//								  1: memory allocated in the function
//				   L			: block width
//				   Y			: weight for original pixel value
//				   xsize		: width  of image data
//				   ysize		: height of image data
//				   pxOrg		: pointer of original image data
//--------------------------------------------------------------------------------------
//	Output		 : pxByte		: pointer of output image data
//				   pxLong		: pointer of output image data
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2005.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _SMOOTH_LINES_FAST				( BYTE prctype,
									  BYTE memtype,
									  LONG L,
									  BYTE Y,
									  LONG xsize,
									  BYTE *pxByte,   // いずれかがNULL
									  LONG *pxLong,   // いずれかがNULL
									  LONG *ACCALLY ) // (xsize+L)余分に長いこと
{
	LONG	i, *A, *B ;
	LONG	L2, L2_, LS, LL, I, J ;
	LONG	CN1, CN2, CN3, CN4, CN5, CN6 ;
	BYTE	*pXB, *endB ;
	LONG	*pXL, *endL ;
	CHAR	lg ;

	//////////////////////
	//////////////////////
	//////////////////////
	// Check parameters.
	//////////////////////
	//////////////////////
	//////////////////////
	if( (prctype>2) )                   { return FALSE ; }
	if( (pxByte==NULL)&&(pxLong==NULL) ){ return FALSE ; }
	//if( (pxLong==NULL) )                { return FALSE ; }
	if( (memtype==0)&&(ACCALLY==NULL) ) { return FALSE ; }
	if( (xsize<=0) )                    { return FALSE ; }
	if( (L<=2) )                        { return FALSE ; }
	if( (L>xsize) )                     { return FALSE ; }

	/////////////////////////////////////////
	/////////////////////////////////////////
	/////////////////////////////////////////
	// Allocate memory for local work area.
	/////////////////////////////////////////
	/////////////////////////////////////////
	/////////////////////////////////////////
	if( memtype==1 ){ ACCALLY = malloc( (xsize+L)*sizeof(LONG) ) ; } // accumulation
	if( ACCALLY==NULL ) return FALSE ; // PGRELIEF 20130810

	///////////////////////////
	///////////////////////////
	///////////////////////////
	// Initialize parameters.
	///////////////////////////
	///////////////////////////
	///////////////////////////
	switch ( prctype ){
		case 0:
			I = L ;
			break ;
		case 1:
			lg = _LOG2X( (ULNG)L ) ;
			if( lg<0 ){
				if( memtype==1 ) free( ACCALLY ) ;
				return FALSE ;
			}
			I = (LONG)lg ;
			break ;
		case 2:
			lg = _LOG2X( (ULNG)(L+Y) ) ;
			if( lg<0 ){
				if( memtype==1 ) free( ACCALLY ) ;
				return FALSE ;
			}
			I = (LONG)lg ;
			break ;
		default:
			if( memtype==1 ) free( ACCALLY ) ;
			return FALSE ;
	}
	LL  = L/2 ;
	L2  = ((L%2)==0)?((LONG)LL):((LONG)(LL+1)) ;
	L2_ = (LONG)(xsize-L2) ;
	LS  = (LONG)(L2-1) ;
	if( (L2>L2_) ){
		if( memtype==1 ) free( ACCALLY ) ;
		return FALSE ;
	}
	CN1 = (LONG)(L-1) ;
	CN2 = (LONG)(xsize-1) ;
	CN3 = (LONG)(xsize-1-LL-L2) ;
	CN4 = (LONG)(L2+LL) ;

	// 原信号をACCALLYに埋め込み
	if( pxByte==NULL ){
		for( i=0 ; i<LS ; i++ ){
			ACCALLY[i]    = (LONG)(2*pxLong[0]-pxLong[LS-i]) ;
		}
		memcpy( (ACCALLY+LS), pxLong, (sizeof(LONG)*xsize) ) ;
		for( i=xsize ; i<xsize+LL ; i++ ){
			ACCALLY[LS+i] = (LONG)(2*pxLong[(xsize-1)]-pxLong[xsize-1-(i-xsize+1)]) ;
		}
	}
	else{
		for( i=0 ; i<LS ; i++ ){
			ACCALLY[i]    = (LONG)(2*pxByte[0]-pxByte[LS-i]) ;
		}
		for( i=0 ; i<xsize ; i++ ){
			ACCALLY[LS+i] = (LONG)(pxByte[i]) ;
		}
		for( i=xsize ; i<xsize+LL ; i++ ){
			ACCALLY[LS+i] = (LONG)(2*pxByte[(xsize-1)]-pxByte[xsize-1-(i-xsize+1)]) ;
		}
	}

	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	// Calculate SUMALLY and ACCALLY.
	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	for( i=1 ; i<xsize+LS+LL ; i++ ){ ACCALLY[i] += (LONG)ACCALLY[i-1] ; }

	CN5 = ACCALLY[CN1] ;
	CN6 = (LONG)(ACCALLY[CN2]-ACCALLY[CN3]) ;
	A   = ACCALLY+CN4 ;
	B   = ACCALLY     ;

	if( pxByte==NULL ){
		pXL  = pxLong       ;
		endL = pxLong+xsize ;
		switch ( prctype ){
			case 0:
				J    = I>>1 ;
				*pXL = (LONG)((CN5+J) /I) ;
				(pXL++) ;
				while( pXL<endL ){
					*pXL = (LONG)((((*A)-(*B))+J) /I) ;
					(A  ++) ;
					(B  ++) ;
					(pXL++) ;
				}
				break ;
			case 1:
				*pXL = (LONG)(CN5>>I) ;
				(pXL++) ;
				while( pXL<endL ){
					*pXL = (LONG)(((*A)-(*B))>>I) ;
					(A  ++) ;
					(B  ++) ;
					(pXL++) ;
				}
				break ;
			case 2:
				*pXL = (LONG)((CN5+Y*(*pXL))>>I) ;
				(pXL++) ;
				while( pXL<endL ){
					*pXL = (LONG)(((*A)-(*B)+(Y*(*pXL)))>>I) ;
					(A  ++) ;
					(B  ++) ;
					(pXL++) ;
				}
				break ;
			default:
				if( memtype==1 ) free( ACCALLY ) ;
				return FALSE ;
		}
	}
	else{
		pXB  = pxByte       ;
		endB = pxByte+xsize ;
		switch ( prctype ){
			case 0:
				J    = I>>1 ;
				*pXB = (BYTE)((CN5+J) /I) ;
				(pXB++) ;
				while( pXB<endB ){
					*pXB = (BYTE)((((*A)-(*B))+J) /I) ;
					(A  ++) ;
					(B  ++) ;
					(pXB++) ;
				}
				break ;
			case 1:
				*pXB = (BYTE)(CN5>>I) ;
				(pXB++) ;
				while( pXB<endB ){
					*pXB = (BYTE)(((*A)-(*B))>>I) ;
					(A  ++) ;
					(B  ++) ;
					(pXB++) ;
				}
				break ;
			case 2:
				*pXB = (BYTE)((CN5+Y*(*pXB))>>I) ;
				(pXB++) ;
				while( pXB<endB ){
					*pXB = (BYTE)(((*A)-(*B)+(Y*(*pXB)))>>I) ;
					(A  ++) ;
					(B  ++) ;
					(pXB++) ;
				}
				break ;
			default:
				if( memtype==1 ) free( ACCALLY ) ;
				return FALSE ;
		}
	}

	///////////////////
	///////////////////
	///////////////////
	// Return (TRUE).
	///////////////////
	///////////////////
	///////////////////
	if( memtype==1 ) free( ACCALLY ) ;
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Subroutine of function "_SMOOTH_IMAGE_FAST".
//--------------------------------------------------------------------------------------
//	Input		 : xsize		: 
//				   ysize		: 
//				   pxOrg		: 
//				   ACCALLY		: 
//				   SUMALLY		: 
//				   CN1			: 
//				   CN2			: 
//				   CN3			: 
//				   CN4			: 
//				   K2			: 
//				   K2_			: 
//				   L2			: 
//				   L2_			: 
//				   KK			: 
//				   J			: 
//--------------------------------------------------------------------------------------
//	Output		 : pP			: 
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2005.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
VOID _SMOOTH_IMAGE_SUB0				( LONG		xsize,
									  LONG		ysize,
									  BYTE*		pxOrg,
									  BYTE*		pP,
									  LONG*		ACCALLY,
									  LONG*		SUMALLY,
									  LONG		CN1,
									  LONG		CN2,
									  LONG		CN3,
									  LONG		CN4,
									  LONG		K2,
									  LONG		K2_,
									  LONG		L2,
									  LONG		L2_,
									  LONG		KK,
									  LONG		J )
{
	LONG	i, j, *A, *B ;
	LONG	CN5, CN6 ;
	BYTE	*p1, *p2 ;

	CN5 = ACCALLY[CN1] ;
	CN6 = (LONG)(ACCALLY[CN2]-ACCALLY[CN3]) ;
	for( j=0 ; j<K2 ; j++ ){
		A = ACCALLY+CN4 ;
		B = ACCALLY     ;
		for( i=0     ; i<L2    ; i++, pP++ ){ *pP = _DIVIDE( CN5, J ) ; }
		for(/*i=L2 */; i<L2_   ; i++, pP++ ){ *pP = _DIVIDE( (LONG)((*(A++))-(*(B++))), J ) ; }
		for(/*i=L2_*/; i<xsize ; i++, pP++ ){ *pP = _DIVIDE( CN6, J ) ; }
	}
	for( j=K2 ; j<K2_ ; j++ ){
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		// Update SUMALLY and ACCALLY.
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		p1 = pxOrg+xsize*(j-K2) ;
		p2 = pxOrg+xsize*(j+KK) ;
		SUMALLY[0] -= *p1 ;
		SUMALLY[0] += *p2 ;
		ACCALLY[0]  = SUMALLY[0] ;
		for( i=1 ; i<xsize ; i++ ){
			ACCALLY[i] = ACCALLY[i-1] ;
			p1++ ;
			p2++ ;
			SUMALLY[i] -= *p1 ;
			SUMALLY[i] += *p2 ;
			ACCALLY[i] += SUMALLY[i] ;
		}
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		CN5 = ACCALLY[CN1] ;
		CN6 = (LONG)(ACCALLY[CN2]-ACCALLY[CN3]) ;
		A   = ACCALLY+CN4 ;
		B   = ACCALLY     ;
		for( i=0     ; i<L2    ; i++, pP++ ){ *pP = _DIVIDE( CN5, J ) ; }
		for(/*i=L2 */; i<L2_   ; i++, pP++ ){ *pP = _DIVIDE( (LONG)((*(A++))-(*(B++))), J ) ; }
		for(/*i=L2_*/; i<xsize ; i++, pP++ ){ *pP = _DIVIDE( CN6, J ) ; }
	}
	for( j=K2_ ; j<ysize ; j++ ){
		A = ACCALLY+CN4 ;
		B = ACCALLY     ;
		for( i=0     ; i<L2    ; i++, pP++ ){ *pP = _DIVIDE( CN5, J ) ; }
		for(/*i=L2 */; i<L2_   ; i++, pP++ ){ *pP = _DIVIDE( (LONG)((*(A++))-(*(B++))), J ) ; }
		for(/*i=L2_*/; i<xsize ; i++, pP++ ){ *pP = _DIVIDE( CN6, J ) ; }
	}
	return ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Subroutine of function "_SMOOTH_IMAGE_FAST".
//--------------------------------------------------------------------------------------
//	Input		 : xsize		: 
//				   ysize		: 
//				   pxOrg		: 
//				   ACCALLY		: 
//				   SUMALLY		: 
//				   CN1			: 
//				   CN2			: 
//				   CN3			: 
//				   CN4			: 
//				   K2			: 
//				   K2_			: 
//				   L2			: 
//				   L2_			: 
//				   KK			: 
//				   J			: 
//--------------------------------------------------------------------------------------
//	Output		 : pP			: 
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2005.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
VOID _SMOOTH_IMAGE_SUB1				( LONG		xsize,
									  LONG		ysize,
									  BYTE*		pxOrg,
									  BYTE*		pP,
									  LONG*		ACCALLY,
									  LONG*		SUMALLY,
									  LONG		CN1,
									  LONG		CN2,
									  LONG		CN3,
									  LONG		CN4,
									  LONG		K2,
									  LONG		K2_,
									  LONG		L2,
									  LONG		L2_,
									  LONG		KK,
									  LONG		J )
{
	LONG	i, j, *A, *B ;
	LONG	CN5, CN6 ;
	BYTE	*p1, *p2 ;

	CN5 = ACCALLY[CN1] ;
	CN6 = (LONG)(ACCALLY[CN2]-ACCALLY[CN3]) ;
	for( j=0 ; j<K2 ; j++ ){
		A = ACCALLY+CN4 ;
		B = ACCALLY     ;
		for( i=0     ; i<L2    ; i++, pP++ ){ *pP = _SHIFT0( CN5, J ) ; }
		for(/*i=L2 */; i<L2_   ; i++, pP++ ){ *pP = _SHIFT0( (LONG)((*(A++))-(*(B++))), J ) ; }
		for(/*i=L2_*/; i<xsize ; i++, pP++ ){ *pP = _SHIFT0( CN6, J ) ; }
	}
	for( j=K2 ; j<K2_ ; j++ ){
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		// Update SUMALLY and ACCALLY.
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		p1 = pxOrg+xsize*(j-K2) ;
		p2 = pxOrg+xsize*(j+KK) ;
		SUMALLY[0] -= *p1 ;
		SUMALLY[0] += *p2 ;
		ACCALLY[0]  = SUMALLY[0] ;
		for( i=1 ; i<xsize ; i++ ){
			ACCALLY[i] = ACCALLY[i-1] ;
			p1++ ;
			p2++ ;
			SUMALLY[i] -= *p1 ;
			SUMALLY[i] += *p2 ;
			ACCALLY[i] += SUMALLY[i] ;
		}
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		CN5 = ACCALLY[CN1] ;
		CN6 = (LONG)(ACCALLY[CN2]-ACCALLY[CN3]) ;
		A   = ACCALLY+CN4 ;
		B   = ACCALLY     ;
		for( i=0     ; i<L2    ; i++, pP++ ){ *pP = _SHIFT0( CN5, J ) ; }
		for(/*i=L2 */; i<L2_   ; i++, pP++ ){ *pP = _SHIFT0( (LONG)((*(A++))-(*(B++))), J ) ; }
		for(/*i=L2_*/; i<xsize ; i++, pP++ ){ *pP = _SHIFT0( CN6, J ) ; }
	}
	for( j=K2_ ; j<ysize ; j++ ){
		A = ACCALLY+CN4 ;
		B = ACCALLY     ;
		for( i=0     ; i<L2    ; i++, pP++ ){ *pP = _SHIFT0( CN5, J ) ; }
		for(/*i=L2 */; i<L2_   ; i++, pP++ ){ *pP = _SHIFT0( (LONG)((*(A++))-(*(B++))), J ) ; }
		for(/*i=L2_*/; i<xsize ; i++, pP++ ){ *pP = _SHIFT0( CN6, J ) ; }
	}
	return ;
}
#if	0
/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Subroutine of function "_SMOOTH_IMAGE_FAST".
//--------------------------------------------------------------------------------------
//	Input		 : xsize		: 
//				   ysize		: 
//				   pxOrg		: 
//				   ACCALLY		: 
//				   SUMALLY		: 
//				   CN1			: 
//				   CN2			: 
//				   CN3			: 
//				   CN4			: 
//				   K2			: 
//				   K2_			: 
//				   L2			: 
//				   L2_			: 
//				   KK			: 
//				   J			: 
//--------------------------------------------------------------------------------------
//	Output		 : pP			: 
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2005.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
VOID _SMOOTH_IMAGE_SUB2				( LONG		xsize,
									  LONG		ysize,
									  BYTE*		pxOrg,
									  BYTE*		pX,
									  BYTE*		pP,
									  LONG*		ACCALLY,
									  LONG*		SUMALLY,
									  LONG		CN1,
									  LONG		CN2,
									  LONG		CN3,
									  LONG		CN4,
									  LONG		K2,
									  LONG		K2_,
									  LONG		L2,
									  LONG		L2_,
									  LONG		KK,
									  LONG		J )
{
	LONG	i, j, CN5, CN6     ;
	LONG	*A, *B             ;
	LONG	*accn0=ACCALLY     ;
	LONG	*accn1=ACCALLY+CN1 ;
	LONG	*accn2=ACCALLY+CN2 ;
	LONG	*accn3=ACCALLY+CN3 ;
	LONG	*accn4=ACCALLY+CN4 ;
	BYTE	*p1, *P1, *p2, *P2 ;

	CN5 = ACCALLY[CN1] ;
	CN6 = (LONG)(ACCALLY[CN2]-ACCALLY[CN3]) ;
	for( j=0 ; j<K2 ; j++ ){
		A = ACCALLY+CN4 ;
		B = ACCALLY     ;
		for( i=0     ; i<L2    ; i++, pP++, pX++ ){ *pP = (BYTE)((CN5          +(*pX))>>J) ; }
		for(/*i=L2 */; i<L2_   ; i++, pP++, pX++ ){ *pP = (BYTE)((*(A++)-*(B++)+(*pX))>>J) ; }
		for(/*i=L2_*/; i<xsize ; i++, pP++, pX++ ){ *pP = (BYTE)((CN6          +(*pX))>>J) ; }
	}
	P1 = pxOrg ;
	P2 = pxOrg+xsize*(K2+KK) ;
	for( j=K2 ; j<K2_ ; j++ ){
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		// Update SUMALLY and ACCALLY.
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		p1 = P1 ;
		p2 = P2 ;
		ACCALLY[0] = (SUMALLY[0]+=(*p2)-(*p1)) ;
		for( i=1 ; i<xsize ; i++ ){
			ACCALLY[i] = ACCALLY[i-1] ;
			p1++ ;
			p2++ ;
			ACCALLY[i] += (SUMALLY[i]+=(*p2)-(*p1)) ;
		}
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		CN5 = *accn1 ; // ACCALLY[CN1] ;
		CN6 = *accn2-*accn3 ; // (LONG)(ACCALLY[CN2]-ACCALLY[CN3]) ;
		A   = accn4  ; // ACCALLY+CN4 ;
		B   = accn0  ;
		for( i=0     ; i<L2    ; i++, pP++, pX++ ){ *pP = (BYTE)((CN5          +(*pX))>>J) ; }
		for(/*i=L2 */; i<L2_   ; i++, pP++, pX++ ){ *pP = (BYTE)((*(A++)-*(B++)+(*pX))>>J) ; }
		for(/*i=L2_*/; i<xsize ; i++, pP++, pX++ ){ *pP = (BYTE)((CN6          +(*pX))>>J) ; }
		P1 += xsize ;
		P2 += xsize ;
	}
	for( j=K2_ ; j<ysize ; j++ ){
		A = ACCALLY+CN4 ;
		B = ACCALLY     ;
		for( i=0     ; i<L2    ; i++, pP++, pX++ ){ *pP = (BYTE)((CN5          +(*pX))>>J) ; }
		for(/*i=L2 */; i<L2_   ; i++, pP++, pX++ ){ *pP = (BYTE)((*(A++)-*(B++)+(*pX))>>J) ; }
		for(/*i=L2_*/; i<xsize ; i++, pP++, pX++ ){ *pP = (BYTE)((CN6          +(*pX))>>J) ; }
	}
	return ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Subroutine of function "_SMOOTH_IMAGE_FAST".
//--------------------------------------------------------------------------------------
//	Input		 : xsize		: 
//				   ysize		: 
//				   pxOrg		: 
//				   ACCALLY		: 
//				   SUMALLY		: 
//				   CN1			: 
//				   CN2			: 
//				   CN3			: 
//				   CN4			: 
//				   K2			: 
//				   K2_			: 
//				   L2			: 
//				   L2_			: 
//				   KK			: 
//				   J			: 
//--------------------------------------------------------------------------------------
//	Output		 : pP			: 
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2005.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
VOID _SMOOTH_IMAGE_SUB3				( LONG		xsize,
									  LONG		ysize,
									  BYTE*		pxOrg,
									  BYTE*		pX,
									  BYTE*		pP,
									  LONG*		ACCALLY,
									  LONG*		SUMALLY,
									  LONG		CN1,
									  LONG		CN2,
									  LONG		CN3,
									  LONG		CN4,
									  LONG		K2,
									  LONG		K2_,
									  LONG		L2,
									  LONG		L2_,
									  LONG		KK,
									  LONG		J,
									  BYTE		Y )
{
	LONG	i, j, CN5, CN6     ;
	LONG	*A, *B             ;
	LONG	*accn0=ACCALLY     ;
	LONG	*accn1=ACCALLY+CN1 ;
	LONG	*accn2=ACCALLY+CN2 ;
	LONG	*accn3=ACCALLY+CN3 ;
	LONG	*accn4=ACCALLY+CN4 ;
	BYTE	*p1, *P1, *p2, *P2 ;

	CN5 = ACCALLY[CN1] ;
	CN6 = (LONG)(ACCALLY[CN2]-ACCALLY[CN3]) ;
	for( j=0 ; j<K2 ; j++ ){
		A = ACCALLY+CN4 ;
		B = ACCALLY     ;
		for( i=0     ; i<L2    ; i++, pP++, pX++ ){ *pP = _SHIFT1( CN5,                       Y, pX, J ) ; }
		for(/*i=L2 */; i<L2_   ; i++, pP++, pX++ ){ *pP = _SHIFT1( (LONG)((*(A++))-(*(B++))), Y, pX, J ) ; }
		for(/*i=L2_*/; i<xsize ; i++, pP++, pX++ ){ *pP = _SHIFT1( CN6,                       Y, pX, J ) ; }
	}
	P1 = pxOrg ;
	P2 = pxOrg+xsize*(K2+KK) ;
	for( j=K2 ; j<K2_ ; j++ ){
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		// Update SUMALLY and ACCALLY.
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		p1 = P1 ;
		p2 = P2 ;
		ACCALLY[0] = (SUMALLY[0]+=(*p2)-(*p1)) ;
		for( i=1 ; i<xsize ; i++ ){
			ACCALLY[i] = ACCALLY[i-1] ;
			p1++ ;
			p2++ ;
			ACCALLY[i] += (SUMALLY[i]+=(*p2)-(*p1)) ;
		}
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		CN5 = *accn1 ; // ACCALLY[CN1] ;
		CN6 = *accn2-*accn3 ; // (LONG)(ACCALLY[CN2]-ACCALLY[CN3]) ;
		A   = accn4  ; // ACCALLY+CN4 ;
		B   = accn0  ;
		for( i=0     ; i<L2    ; i++, pP++, pX++ ){ *pP = _SHIFT1( CN5,                       Y, pX, J ) ; }
		for(/*i=L2 */; i<L2_   ; i++, pP++, pX++ ){ *pP = _SHIFT1( (LONG)((*(A++))-(*(B++))), Y, pX, J ) ; }
		for(/*i=L2_*/; i<xsize ; i++, pP++, pX++ ){ *pP = _SHIFT1( CN6,                       Y, pX, J ) ; }
		P1 += xsize ;
		P2 += xsize ;
	}
	for( j=K2_ ; j<ysize ; j++ ){
		A = ACCALLY+CN4 ;
		B = ACCALLY     ;
		for( i=0     ; i<L2    ; i++, pP++, pX++ ){ *pP = _SHIFT1( CN5,                       Y, pX, J ) ; }
		for(/*i=L2 */; i<L2_   ; i++, pP++, pX++ ){ *pP = _SHIFT1( (LONG)((*(A++))-(*(B++))), Y, pX, J ) ; }
		for(/*i=L2_*/; i<xsize ; i++, pP++, pX++ ){ *pP = _SHIFT1( CN6,                       Y, pX, J ) ; }
	}
	return ;
}
#endif//0
/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Smooth 8-bit image data.
//				   Based on moving average method.
//--------------------------------------------------------------------------------------
//	Input		 : prctype		: smoothing type
//								  0: averaged by division  (SUM/(K*L))
//								  1: averaged by bit-shift (SUM>>xxxx)
//								  2: averaged by bit-shift, weighted
//									 (SUM+Y*P)>>xxxx(P:pixel value), KxL+Y = 2^xxxx
//				   memtype		: memory type
//								  0: memory allocated in advance
//								  1: memory allocated in the function
//				   L			: block width
//				   K			: block height
//				   Y			: weight for original pixel value
//				   xsize		: width  of image data
//				   ysize		: height of image data
//				   pxLin		: buffer for processing
//				   pxOrg		: pointer of original image data
//--------------------------------------------------------------------------------------
//	Output		 : pxOrg		: pointer of output image data (memtype=1)
//				   pxPrc		: pointer of output image data (memtype=0)
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2005.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _SMOOTH_IMAGE_FAST				( BYTE prctype,
									  BYTE memtype,
									  LONG L,
									  LONG K,
									  BYTE Y,
									  LONG xsize,
									  LONG ysize,
									  LONG *pxLin, // LONG 2行分必要
									  BYTE *pxOrg, // BYTE 1面分必要
									  BYTE *pxPrc )
{
	LONG	i, j, I, J, M=0          ;
	//LONG	LP0, LP1                 ;
	LONG	K2, K2_, L2, L2_, KK, LL ;
	LONG	CN1, CN2, CN3, CN4       ;
	LONG	*SUMALLY, *Sum           ;
	LONG	*ACCALLY, *Acc           ;
	BYTE	*DUMYIMG                 ;
	BYTE	*p0, *pX, *pP            ;
	CHAR	lg                       ;
	//////////////////////////////////
	LONG	CN5, CN6, *A, *B         ;
	LONG	*accn0, *accn1, *accn2   ;
	LONG	*accn3, *accn4           ;
	BYTE	*p1, *P1, *p2, *P2       ;

	//////////////////////
	//////////////////////
	//////////////////////
	// Check parameters.
	//////////////////////
	//////////////////////
	//////////////////////
	if( (prctype>3)||(memtype>1)     ){ return FALSE ; }
	if( (pxOrg==NULL)                ){ return FALSE ; }
	if( (memtype==0)&&(pxPrc==NULL)  ){ return FALSE ; }
	if( (xsize<=0)||(ysize<=0)       ){ return FALSE ; }
	if( (prctype<3)&&((L<=2)||(K<=2))){ return FALSE ; }
	if( (L>xsize)||(K>ysize)         ){ return FALSE ; }

	/////////////////////////////////////////
	/////////////////////////////////////////
	/////////////////////////////////////////
	// Allocate memory for local work area.
	/////////////////////////////////////////
	/////////////////////////////////////////
	/////////////////////////////////////////
	if( memtype==1 ){
		SUMALLY = malloc( xsize*sizeof(LONG) ) ; // sum of each row 
		ACCALLY = malloc( xsize*sizeof(LONG) ) ; // accumulation
		DUMYIMG = malloc( xsize*ysize*sizeof(BYTE) ) ;
	}
	else{
		SUMALLY = pxLin ;       // sum of each row 
		ACCALLY = pxLin+xsize ; // accumulation
		DUMYIMG = pxPrc ;
	}
	if( (SUMALLY==NULL) || (ACCALLY==NULL) || (DUMYIMG==NULL) ){
		return	FALSE   ;
	}

	///////////////////////////
	///////////////////////////
	///////////////////////////
	// Initialize parameters.
	///////////////////////////
	///////////////////////////
	///////////////////////////
	I = L*K ;
	switch ( prctype ){
		case 0:
			J = I ;
			break ;
		case 1:
			lg = _LOG2X( (ULNG)I ) ;
			if( lg<0 ){
				if( memtype==1 ){
					free( SUMALLY ) ;
					free( ACCALLY ) ;
					free( DUMYIMG ) ;
				}
				return FALSE ;
			}
			J = (LONG)lg ;
			break ;
		case 2:
			lg = _LOG2X( (ULNG)(I+Y) ) ;
			if( lg<0 ){
				if( memtype==1 ){
					free( SUMALLY ) ;
					free( ACCALLY ) ;
					free( DUMYIMG ) ;
				}
				return FALSE ;
			}
			J = (LONG)lg ;
			break ;
		case 3: // (LxL)xK + (Y)xP
			lg = _LOG2X( (ULNG)(L*L*K+Y) ) ;
			if( lg<0 ){
				if( memtype==1 ){
					free( SUMALLY ) ;
					free( ACCALLY ) ;
					free( DUMYIMG ) ;
				}
				return FALSE ;
			}
			J = (LONG)lg ;
			M = K        ; // ﾄﾘｯｸ
			K = L        ; // ﾄﾘｯｸ
			break ;
		default:
			if( memtype==1 ){
				free( SUMALLY ) ;
				free( ACCALLY ) ;
				free( DUMYIMG ) ;
			}
			return FALSE ;
	}
	LL  = L/2                                  ;
	KK  = K/2                                  ;
	L2  = ((L%2)==0)?((LONG)LL):((LONG)(LL+1)) ;
	K2  = ((K%2)==0)?((LONG)KK):((LONG)(KK+1)) ;
	L2_ = (LONG)(xsize-L2)                     ;
	K2_ = (LONG)(ysize-K2)                     ;
	if( (L2>L2_)||(K2>K2_) ){
		if( memtype==1 ){
			free( SUMALLY ) ;
			free( ACCALLY ) ;
			free( DUMYIMG ) ;
		}
		return FALSE ;
	}
	CN1 = (LONG)(L-1)                          ;
	CN2 = (LONG)(xsize-1)                      ;
	CN3 = (LONG)(xsize-1-LL-L2)                ;
	CN4 = (LONG)(L2+LL)                        ;
	//LP0 = L2_-L2                               ;
	//LP1 = xsize-L2_                            ;

	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	// Calculate SUMALLY and ACCALLY.
	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	p0 = pxOrg ;
	pX = p0    ;
	///////////////////////////////////////////
	///////////////////////////////////////////
	SUMALLY[0] = 0 ;
	for( j=0 ; j<K ; j++, pX+=xsize ){ SUMALLY[0] += *pX ; }
	ACCALLY[0] = SUMALLY[0] ;
	p0++ ;
	///////////////////////////////////////////
	///////////////////////////////////////////
	Acc = ACCALLY+1 ;
	Sum = SUMALLY+1 ;
	i   = xsize  -1 ;
	while( i-- ){
	//for( i=1 ; i<xsize ; i++ ){
		//ACCALLY[i] = ACCALLY[i-1] ;
		*Acc = *(Acc-1)   ;
		pX   = p0         ;
		///////////////////////////////////////////
		///////////////////////////////////////////
		//SUMALLY[i] = 0 ;
		*Sum = 0          ;
		j    = K          ;
		while( j-- ){
		//for( j=0 ; j<K ; j++ ){
			//SUMALLY[i] += *pX ;
			*Sum += *pX   ;
			pX   += xsize ;
		}
		//ACCALLY[i] += SUMALLY[i] ;
		*Acc += *Sum      ;
		///////////////////////////////////////////
		///////////////////////////////////////////
		p0 ++             ;
		Acc++             ;
		Sum++             ;
	}
	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////

	pX = pxOrg ;
	if( memtype==1 ){ pP = DUMYIMG ; }
	else            { pP = pxPrc   ; }

	switch ( prctype ){
		case 0:
			////////////////////////////////////////////////////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////////////////////////////////////
			_SMOOTH_IMAGE_SUB0( xsize,ysize,pxOrg,   pP,ACCALLY,SUMALLY,CN1,CN2,CN3,CN4,K2,K2_,L2,L2_,KK,J   ) ;
			////////////////////////////////////////////////////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////////////////////////////////////
			break ;
		case 1:
			////////////////////////////////////////////////////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////////////////////////////////////
			_SMOOTH_IMAGE_SUB1( xsize,ysize,pxOrg,   pP,ACCALLY,SUMALLY,CN1,CN2,CN3,CN4,K2,K2_,L2,L2_,KK,J   ) ;
			////////////////////////////////////////////////////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////////////////////////////////////
			////////////////////////////////////////////////////////////////////////////////////////////////////
			break ;
		case 2:
			accn0 = ACCALLY     ;
			accn1 = ACCALLY+CN1 ;
			accn2 = ACCALLY+CN2 ;
			accn3 = ACCALLY+CN3 ;
			accn4 = ACCALLY+CN4 ;
			if( Y==1 ){
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				/*
				_SMOOTH_IMAGE_SUB2( xsize,ysize,pxOrg,pX,pP,ACCALLY,SUMALLY,CN1,CN2,CN3,CN4,K2,K2_,L2,L2_,KK,J   ) ;
				//*/
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				CN5 = ACCALLY[CN1] ;
				CN6 = (LONG)(ACCALLY[CN2]-ACCALLY[CN3]) ;
				for( j=0 ; j<K2 ; j++ ){
					A = ACCALLY+CN4 ;
					B = ACCALLY     ;
					for( i=0     ; i<L2    ; i++, pP++, pX++ ){ *pP = (BYTE)((CN5          +(*pX))>>J) ; }
					for(/*i=L2 */; i<L2_   ; i++, pP++, pX++ ){ *pP = (BYTE)((*(A++)-*(B++)+(*pX))>>J) ; }
					for(/*i=L2_*/; i<xsize ; i++, pP++, pX++ ){ *pP = (BYTE)((CN6          +(*pX))>>J) ; }
				}
				P1 = pxOrg ;
				P2 = pxOrg+xsize*(K2+KK) ;
				for( j=K2 ; j<K2_ ; j++ ){
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					// Update SUMALLY and ACCALLY.
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					p1  = P1 ;
					p2  = P2 ;
					ACCALLY[0] = (SUMALLY[0]+=(*p2)-(*p1)) ;
					Acc = ACCALLY+1 ;
					Sum = SUMALLY+1 ;
					i   = xsize  -1 ;
					while( i-- ){
					//for( i=1 ; i<xsize ; i++ ){
						//ACCALLY[i] = ACCALLY[i-1] ;
						*Acc  = *(Acc-1)              ;
						p1++                          ;
						p2++                          ;
						//ACCALLY[i] += (SUMALLY[i]+=(*p2)-(*p1)) ;
						*Acc += ((*Sum)+=(*p2)-(*p1)) ;
						Acc++                         ;
						Sum++                         ;
					}
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					CN5 = *accn1        ; // ACCALLY[CN1] ;
					CN6 = *accn2-*accn3 ; // (LONG)(ACCALLY[CN2]-ACCALLY[CN3]) ;
					A   = accn4         ; // ACCALLY+CN4 ;
					B   = accn0         ;
					//i=L2 ;
					//while( i-- ){
					for( i=0     ; i<L2    ; ){
						*pP = (BYTE)((CN5+(*pX))>>J) ;
						i++, pP++, pX++ ;
					}
					//i=LP0 ;
					//while( i-- ){
					for(/*i=L2 */; i<L2_   ; ){
						*pP = (BYTE)((*A-*B+*pX)>>J) ;
						i++, pP++, pX++, A++, B++ ;
					}
					//i=LP1 ;
					//while( i-- ){
					for(/*i=L2_*/; i<xsize ; ){
						*pP = (BYTE)((CN6+(*pX))>>J) ;
						i++, pP++, pX++ ;
					}
					P1 += xsize ;
					P2 += xsize ;
				}
				for( j=K2_ ; j<ysize ; j++ ){
					A = ACCALLY+CN4 ;
					B = ACCALLY     ;
					for( i=0     ; i<L2    ; i++, pP++, pX++ ){ *pP = (BYTE)((CN5          +(*pX))>>J) ; }
					for(/*i=L2 */; i<L2_   ; i++, pP++, pX++ ){ *pP = (BYTE)((*(A++)-*(B++)+(*pX))>>J) ; }
					for(/*i=L2_*/; i<xsize ; i++, pP++, pX++ ){ *pP = (BYTE)((CN6          +(*pX))>>J) ; }
				}
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
			}
			else      {
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				/*
				_SMOOTH_IMAGE_SUB3( xsize,ysize,pxOrg,pX,pP,ACCALLY,SUMALLY,CN1,CN2,CN3,CN4,K2,K2_,L2,L2_,KK,J,Y ) ;
				//*/
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				CN5 = ACCALLY[CN1] ;
				CN6 = (LONG)(ACCALLY[CN2]-ACCALLY[CN3]) ;
				for( j=0 ; j<K2 ; j++ ){
					A = ACCALLY+CN4 ;
					B = ACCALLY     ;
					for( i=0     ; i<L2    ; i++, pP++, pX++ ){ *pP = _SHIFT1( CN5,                       Y, pX, J ) ; }
					for(/*i=L2 */; i<L2_   ; i++, pP++, pX++ ){ *pP = _SHIFT1( (LONG)((*(A++))-(*(B++))), Y, pX, J ) ; }
					for(/*i=L2_*/; i<xsize ; i++, pP++, pX++ ){ *pP = _SHIFT1( CN6,                       Y, pX, J ) ; }
				}
				P1 = pxOrg ;
				P2 = pxOrg+xsize*(K2+KK) ;
				for( j=K2 ; j<K2_ ; j++ ){
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					// Update SUMALLY and ACCALLY.
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					p1  = P1 ;
					p2  = P2 ;
					ACCALLY[0] = (SUMALLY[0]+=(*p2)-(*p1)) ;
					Acc = ACCALLY+1 ;
					Sum = SUMALLY+1 ;
					i   = xsize  -1 ;
					while( i-- ){
					//for( i=1 ; i<xsize ; i++ ){
						//ACCALLY[i] = ACCALLY[i-1] ;
						*Acc  = *(Acc-1)              ;
						p1++ ;
						p2++ ;
						//ACCALLY[i] += (SUMALLY[i]+=(*p2)-(*p1)) ;
						*Acc += ((*Sum)+=(*p2)-(*p1)) ;
						Acc++                         ;
						Sum++                         ;
					}
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					CN5 = *accn1        ; // ACCALLY[CN1] ;
					CN6 = *accn2-*accn3 ; // (LONG)(ACCALLY[CN2]-ACCALLY[CN3]) ;
					A   = accn4         ; // ACCALLY+CN4 ;
					B   = accn0         ;
					for( i=0     ; i<L2    ; ){
						*pP = _SHIFT1( CN5,           Y, pX, J ) ;
						i++, pP++, pX++ ;
					}
					for(/*i=L2 */; i<L2_   ; ){
						*pP = _SHIFT1( (LONG)(*A-*B), Y, pX, J ) ;
						i++, pP++, pX++, A++, B++ ;
					}
					for(/*i=L2_*/; i<xsize ; ){
						*pP = _SHIFT1( CN6,           Y, pX, J ) ;
						i++, pP++, pX++ ;
					}
					P1 += xsize ;
					P2 += xsize ;
				}
				for( j=K2_ ; j<ysize ; j++ ){
					A = ACCALLY+CN4 ;
					B = ACCALLY     ;
					for( i=0     ; i<L2    ; i++, pP++, pX++ ){ *pP = _SHIFT1( CN5,                       Y, pX, J ) ; }
					for(/*i=L2 */; i<L2_   ; i++, pP++, pX++ ){ *pP = _SHIFT1( (LONG)((*(A++))-(*(B++))), Y, pX, J ) ; }
					for(/*i=L2_*/; i<xsize ; i++, pP++, pX++ ){ *pP = _SHIFT1( CN6,                       Y, pX, J ) ; }
				}
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
			}
			break ;
		case 3:
			accn0 = ACCALLY     ;
			accn1 = ACCALLY+CN1 ;
			accn2 = ACCALLY+CN2 ;
			accn3 = ACCALLY+CN3 ;
			accn4 = ACCALLY+CN4 ;
			if( Y==1 ){
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				/*
				_SMOOTH_IMAGE_SUB2( xsize,ysize,pxOrg,pX,pP,ACCALLY,SUMALLY,CN1,CN2,CN3,CN4,K2,K2_,L2,L2_,KK,J   ) ;
				//*/
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				CN5 = ACCALLY[CN1] ;
				CN6 = (LONG)(ACCALLY[CN2]-ACCALLY[CN3]) ;
				for( j=0 ; j<K2 ; j++ ){
					A = ACCALLY+CN4 ;
					B = ACCALLY     ;
					for( i=0     ; i<L2    ; i++, pP++, pX++ ) *pP = _SHIFT2(CN5,			 M,pX,J);//(BYTE)((CN5          +(*pX))>>J) ;
					for(/*i=L2 */; i<L2_   ; i++, pP++, pX++ ) *pP = _SHIFT2((*(A++)-*(B++)),M,pX,J);//(BYTE)((*(A++)-*(B++)+(*pX))>>J) ;
					for(/*i=L2_*/; i<xsize ; i++, pP++, pX++ ) *pP = _SHIFT2(CN6,            M,pX,J);//(BYTE)((CN6          +(*pX))>>J) ;
				}
				P1 = pxOrg ;
				P2 = pxOrg+xsize*(K2+KK) ;
				for( j=K2 ; j<K2_ ; j++ ){
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					// Update SUMALLY and ACCALLY.
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					p1  = P1 ;
					p2  = P2 ;
					ACCALLY[0] = (SUMALLY[0]+=(*p2)-(*p1)) ;
					Acc = ACCALLY+1 ;
					Sum = SUMALLY+1 ;
					i   = xsize  -1 ;
					while( i-- ){
					//for( i=1 ; i<xsize ; i++ ){
						//ACCALLY[i] = ACCALLY[i-1] ;
						*Acc  = *(Acc-1)              ;
						p1++                          ;
						p2++                          ;
						//ACCALLY[i] += (SUMALLY[i]+=(*p2)-(*p1)) ;
						*Acc += ((*Sum)+=(*p2)-(*p1)) ;
						Acc++                         ;
						Sum++                         ;
					}
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					CN5 = *accn1        ; // ACCALLY[CN1] ;
					CN6 = *accn2-*accn3 ; // (LONG)(ACCALLY[CN2]-ACCALLY[CN3]) ;
					A   = accn4         ; // ACCALLY+CN4 ;
					B   = accn0         ;
					//i=L2 ;
					//while( i-- ){
					for( i=0     ; i<L2    ; ){
						*pP = _SHIFT2(CN5,    M,pX,J);//(BYTE)((CN5+(*pX))>>J) ;
						i++, pP++, pX++ ;
					}
					//i=LP0 ;
					//while( i-- ){
					for(/*i=L2 */; i<L2_   ; ){
						*pP = _SHIFT2((*A-*B),M,pX,J);//(BYTE)((*A-*B+*pX)>>J) ;
						i++, pP++, pX++, A++, B++ ;
					}
					//i=LP1 ;
					//while( i-- ){
					for(/*i=L2_*/; i<xsize ; ){
						*pP = _SHIFT2(CN6,    M,pX,J);//(BYTE)((CN6+(*pX))>>J) ;
						i++, pP++, pX++ ;
					}
					P1 += xsize ;
					P2 += xsize ;
				}
				for( j=K2_ ; j<ysize ; j++ ){
					A = ACCALLY+CN4 ;
					B = ACCALLY     ;
					for( i=0     ; i<L2    ; i++, pP++, pX++ ) *pP = _SHIFT2(CN5,            M,pX,J);//(BYTE)((CN5          +(*pX))>>J) ;
					for(/*i=L2 */; i<L2_   ; i++, pP++, pX++ ) *pP = _SHIFT2((*(A++)-*(B++)),M,pX,J);//(BYTE)((*(A++)-*(B++)+(*pX))>>J) ;
					for(/*i=L2_*/; i<xsize ; i++, pP++, pX++ ) *pP = _SHIFT2(CN6,            M,pX,J);//(BYTE)((CN6          +(*pX))>>J) ;
				}
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
			}
			else      {
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				/*
				_SMOOTH_IMAGE_SUB3( xsize,ysize,pxOrg,pX,pP,ACCALLY,SUMALLY,CN1,CN2,CN3,CN4,K2,K2_,L2,L2_,KK,J,Y ) ;
				//*/
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				CN5 = ACCALLY[CN1] ;
				CN6 = (LONG)(ACCALLY[CN2]-ACCALLY[CN3]) ;
				for( j=0 ; j<K2 ; j++ ){
					A = ACCALLY+CN4 ;
					B = ACCALLY     ;
					for( i=0     ; i<L2    ; i++, pP++, pX++ ){ *pP = _SHIFT3( CN5,                       M, Y, pX, J ) ; }
					for(/*i=L2 */; i<L2_   ; i++, pP++, pX++ ){ *pP = _SHIFT3( (LONG)((*(A++))-(*(B++))), M, Y, pX, J ) ; }
					for(/*i=L2_*/; i<xsize ; i++, pP++, pX++ ){ *pP = _SHIFT3( CN6,                       M, Y, pX, J ) ; }
				}
				P1 = pxOrg ;
				P2 = pxOrg+xsize*(K2+KK) ;
				for( j=K2 ; j<K2_ ; j++ ){
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					// Update SUMALLY and ACCALLY.
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					p1  = P1 ;
					p2  = P2 ;
					ACCALLY[0] = (SUMALLY[0]+=(*p2)-(*p1)) ;
					Acc = ACCALLY+1 ;
					Sum = SUMALLY+1 ;
					i   = xsize  -1 ;
					while( i-- ){
					//for( i=1 ; i<xsize ; i++ ){
						//ACCALLY[i] = ACCALLY[i-1] ;
						*Acc  = *(Acc-1)              ;
						p1++ ;
						p2++ ;
						//ACCALLY[i] += (SUMALLY[i]+=(*p2)-(*p1)) ;
						*Acc += ((*Sum)+=(*p2)-(*p1)) ;
						Acc++                         ;
						Sum++                         ;
					}
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					////////////////////////////////////////////////////////////////
					CN5 = *accn1        ; // ACCALLY[CN1] ;
					CN6 = *accn2-*accn3 ; // (LONG)(ACCALLY[CN2]-ACCALLY[CN3]) ;
					A   = accn4         ; // ACCALLY+CN4 ;
					B   = accn0         ;
					for( i=0     ; i<L2    ; ){
						*pP = _SHIFT3( CN5,           M, Y, pX, J ) ;
						i++, pP++, pX++ ;
					}
					for(/*i=L2 */; i<L2_   ; ){
						*pP = _SHIFT3( (LONG)(*A-*B), M, Y, pX, J ) ;
						i++, pP++, pX++, A++, B++ ;
					}
					for(/*i=L2_*/; i<xsize ; ){
						*pP = _SHIFT3( CN6,           M, Y, pX, J ) ;
						i++, pP++, pX++ ;
					}
					P1 += xsize ;
					P2 += xsize ;
				}
				for( j=K2_ ; j<ysize ; j++ ){
					A = ACCALLY+CN4 ;
					B = ACCALLY     ;
					for( i=0     ; i<L2    ; i++, pP++, pX++ ){ *pP = _SHIFT3( CN5,                       M, Y, pX, J ) ; }
					for(/*i=L2 */; i<L2_   ; i++, pP++, pX++ ){ *pP = _SHIFT3( (LONG)((*(A++))-(*(B++))), M, Y, pX, J ) ; }
					for(/*i=L2_*/; i<xsize ; i++, pP++, pX++ ){ *pP = _SHIFT3( CN6,                       M, Y, pX, J ) ; }
				}
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
				////////////////////////////////////////////////////////////////////////////////////////////////////
			}
			break ;
		default:
			if( memtype==1 ){
				free( SUMALLY ) ;
				free( ACCALLY ) ;
				free( DUMYIMG ) ;
			}
			return FALSE ;
	}

	if( memtype==1 ){
		memcpy( pxOrg, DUMYIMG, xsize*ysize*sizeof(BYTE) ) ;
		free( SUMALLY ) ;
		free( ACCALLY ) ;
		free( DUMYIMG ) ;
	}

	///////////////////
	///////////////////
	///////////////////
	// Return (TRUE).
	///////////////////
	///////////////////
	///////////////////	
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Subroutine of function "_MEDIAN_FILTER_FAST".
//--------------------------------------------------------------------------------------
//	Input		 : prctype		: processing area
//				   X0			: block width
//				   X1			: block height
//				   Y,S			: coefficients for the calculation
//				   pX			: pointer of original pixel data
//				   maxally		: maximum value sequence for each ROW
//				   minally		: minimum value sequence for each ROW
//--------------------------------------------------------------------------------------
//	Output		 : P			: pointer of output pixel data
//				   maxmax		: maximum value of maxally[]
//				   minmin		: minimum value of minally[]
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2005.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
BYTE GetMedianValue					( BYTE prctype,
									  LONG X0,
									  LONG X1,
									  BYTE Y,
									  BYTE S,
									  BYTE *pX,
									  BYTE *maxmax,
									  BYTE *minmin,
									  BYTE *maxally,
									  BYTE *minally )
{
	LONG	i ;
	LONG	X0P, X0M, X1M ;
	BYTE	P, X ;

	X0P = (LONG)(X0+1) ;
	X0M = (LONG)(X0-1) ;
	X1M = (LONG)(X1-1) ;
	switch( prctype ){
		case 0:
			*maxmax = maxally[X0] ;
			*minmin = minally[X0] ;
			for( i=X0P ; i<X1 ; i++ ){
				if( maxally[i]>(*maxmax) ){ *maxmax = maxally[i] ; }
				if( minally[i]<(*minmin) ){ *minmin = minally[i] ; }
				////if( maxally[i]<(*maxmax) ){ *maxmax = maxally[i] ; }
				////if( minally[i]>(*minmin) ){ *minmin = minally[i] ; }
			}
			break ;
		case 1:
			if( maxally[X0M]==(*maxmax) ){
				*maxmax = maxally[X0] ;
				for( i=X0P ; i<X1 ; i++ ){ if( maxally[i]>(*maxmax) ){ *maxmax = maxally[i] ; } }
				////for( i=X0P ; i<X1 ; i++ ){ if( maxally[i]<(*maxmax) ){ *maxmax = maxally[i] ; } }
			}
			else{ if( maxally[X1M]>(*maxmax) ){ *maxmax = maxally[X1M] ; } }
			////else{ if( maxally[X1M]<(*maxmax) ){ *maxmax = maxally[X1M] ; } }
			if( minally[X0M]==(*minmin) ){
				*minmin = minally[X0] ;
				for( i=X0P ; i<X1 ; i++ ){ if( minally[i]<(*minmin) ){ *minmin = minally[i] ; } }
				////for( i=X0P ; i<X1 ; i++ ){ if( minally[i]>(*minmin) ){ *minmin = minally[i] ; } }
			}
			else{ if( minally[X1M]<(*minmin) ){ *minmin = minally[X1M] ; } }
			////else{ if( minally[X1M]>(*minmin) ){ *minmin = minally[X1M] ; } }
			break ;
		default:
			return ( PXMIN ) ;
	}
	X = (BYTE)(((*maxmax)+(*minmin))>>1) ;
	if( (*pX)>X ){ P = (BYTE)(((*maxmax)+Y*(*pX))>>S) ; }
	else         { P = (BYTE)(((*minmin)+Y*(*pX))>>S) ; }
	return ( P ) ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : M E D I A N  F I L T E R
//--------------------------------------------------------------------------------------
//	Input		 : memtype		: memory type
//								  0: memory allocated in advance
//								  1: memory allocated in the function
//				   L			: block width
//				   K			: block height
//				   Y			: weight for original pixel value (0~8)
//								  0: median value most weighted
//								  8: original pixel value most weighted
//				   xsize		: width  of image data
//				   ysize		: height of image data
//				   pxOrg		: pointer of original image data
//--------------------------------------------------------------------------------------
//	Output		 : pxPrc		: pointer of output image data (memtype=0)
//				   pxOrg		: pointer of output image data (memtype=1)
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2007.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _MEDIAN_FILTER_FAST			( BYTE memtype,
									  LONG L,
									  LONG K,
									  BYTE Y,
									  LONG xsize,
									  LONG ysize,
									  BYTE *pxOrg,
									  BYTE *pxPrc )
{
	LONG	i, j, k, A, B ;
	LONG	K2, K2_, L2, L2_, KK, LL ;
	LONG	CN1, CN2, CN3, CN4, CN5 ;
	BYTE	*p0, *p1, *p2, *p3, *p4, *pX, *pP ;
	BYTE	*DUMYIMG, MAXMAX, MINMIN, S ;

	//////////////////////
	//////////////////////
	//////////////////////
	// Check parameters.
	//////////////////////
	//////////////////////
	//////////////////////
	if( (memtype>1) )                { return FALSE ; }
	if( (pxOrg==NULL) )              { return FALSE ; }
	if( (memtype==0)&&(pxPrc==NULL) ){ return FALSE ; }
	if( (xsize<=0)||(ysize<=0) )     { return FALSE ; }
	if( (L<=2)||(K<=2) )             { return FALSE ; }
	if( (L>xsize)||(K>ysize) )       { return FALSE ; }
	if( (Y>8) )                      { return FALSE ; }

	/////////////////////////////////////////
	/////////////////////////////////////////
	/////////////////////////////////////////
	// Allocate memory for local work area.
	/////////////////////////////////////////
	/////////////////////////////////////////
	/////////////////////////////////////////
	if( memtype==1 ){
		MAXALLY = malloc( xsize*      sizeof(BYTE) ) ;
		MINALLY = malloc( xsize*      sizeof(BYTE) ) ;
		DUMYIMG = malloc( xsize*ysize*sizeof(BYTE) ) ;
		if( (MAXALLY==NULL) || (MINALLY==NULL) || (DUMYIMG==NULL) ){
			return	FALSE ;
		}
	}
	else{
		if( (MAXALLY==NULL) || (MINALLY==NULL) ){
			return	FALSE ;
		}
		DUMYIMG = NULL ; // 警告対策
	}

	///////////////////////////
	///////////////////////////
	///////////////////////////
	// Initialize parameters.
	///////////////////////////
	///////////////////////////
	///////////////////////////
	LL  = L/2 ;
	KK  = K/2 ;
	L2  = ((L%2)==0)?((LONG)LL):((LONG)(LL+1)) ;
	K2  = ((K%2)==0)?((LONG)KK):((LONG)(KK+1)) ;
	L2_ = (LONG)(xsize-L2) ;
	K2_ = (LONG)(ysize-K2) ;
	CN1 = (LONG)(1-L2) ;
	CN2 = (LONG)(1+LL) ;
	CN3 = (LONG)(xsize-LL-L2) ;
	CN4 = (LONG)(L2+CN1) ;
	CN5 = (LONG)(L2+CN2) ;
	S   = Y ;
	Y   = (BYTE)(_POW2X((ULNG)S)-1) ;

	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	// Calculate MAXALLY and MINALLY.
	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	p0 = pxOrg ;
	for( i=0 ; i<xsize ; i++ ){
		pX = p0 ;
		MAXALLY[i] = MINALLY[i] = (*pX) ;
		pX += xsize ;
		for( j=1 ; j<K ; j++ ){
			if     ( (*pX)>MAXALLY[i] ){ MAXALLY[i] = (*pX) ; }
			else if( (*pX)<MINALLY[i] ){ MINALLY[i] = (*pX) ; }
			pX += xsize ;
		}
		p0++ ;
	}
	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////////

	pX = pxOrg ;
	if( memtype==1 ){ pP = DUMYIMG ; }
	else            { pP = pxPrc   ; }

	for( j=0 ; j<K2 ; j++ ){
		A = CN4 ;
		B = CN5 ;
		for( i=0   ; i<L2    ; i++, pP++, pX++ ){ *pP = GetMedianValue( 0, (0),   (L),     Y, S, pX, &MAXMAX, &MINMIN, MAXALLY, MINALLY ) ; }
		for( i=L2  ; i<L2_   ; i++, pP++, pX++ ){ *pP = GetMedianValue( 1, (A++), (B++),   Y, S, pX, &MAXMAX, &MINMIN, MAXALLY, MINALLY ) ; }
		for( i=L2_ ; i<xsize ; i++, pP++, pX++ ){ *pP = GetMedianValue( 1, (CN3), (xsize), Y, S, pX, &MAXMAX, &MINMIN, MAXALLY, MINALLY ) ; }
	}
	p0 = pxOrg ;
	p1 = pxOrg+xsize*(K2+KK) ;
	for( j=K2 ; j<K2_ ; j++ ){
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		// Update MAXALLY and MINALLY.
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		p2 = p0 ;
		p3 = p1 ;
		for( i=0 ; i<xsize ; i++ ){
			p4 = p2 ;
			if( MAXALLY[i]==(*p4) ){
				p4 += xsize ;
				MAXALLY[i] = (*p4) ;
				for( k=0 ; k<(LONG)(K-1) ; k++ ){
					p4 += xsize ;
					if( (*p4)>MAXALLY[i] ){ MAXALLY[i] = (*p4) ; }
				}
			}
			else{   if( (*p3)>MAXALLY[i] ){ MAXALLY[i] = (*p3) ; } }
			p4 = p2 ;
			if( MINALLY[i]==(*p4) ){
				p4 += xsize ;
				MINALLY[i] = (*p4) ;
				for( k=0 ; k<(LONG)(K-1) ; k++ ){
					p4 += xsize ;
					if( (*p4)<MINALLY[i] ){ MINALLY[i] = (*p4) ; }
				}
			}
			else{   if( (*p3)<MINALLY[i] ){ MINALLY[i] = (*p3) ; } }
			p2++ ;
			p3++ ;
		}
		p0 += xsize ;
		p1 += xsize ;
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////
		A = CN4 ;
		B = CN5 ;
		for( i=0   ; i<L2    ; i++, pP++, pX++ ){ *pP = GetMedianValue( 0, (0),   (L),     Y, S, pX, &MAXMAX, &MINMIN, MAXALLY, MINALLY ) ; }
		for( i=L2  ; i<L2_   ; i++, pP++, pX++ ){ *pP = GetMedianValue( 1, (A++), (B++),   Y, S, pX, &MAXMAX, &MINMIN, MAXALLY, MINALLY ) ; }
		for( i=L2_ ; i<xsize ; i++, pP++, pX++ ){ *pP = GetMedianValue( 1, (CN3), (xsize), Y, S, pX, &MAXMAX, &MINMIN, MAXALLY, MINALLY ) ; }
	}
	for( j=K2_ ; j<ysize ; j++ ){
		A = CN4 ;
		B = CN5 ;
		for( i=0   ; i<L2    ; i++, pP++, pX++ ){ *pP = GetMedianValue( 0, (0),   (L),     Y, S, pX, &MAXMAX, &MINMIN, MAXALLY, MINALLY ) ; }
		for( i=L2  ; i<L2_   ; i++, pP++, pX++ ){ *pP = GetMedianValue( 1, (A++), (B++),   Y, S, pX, &MAXMAX, &MINMIN, MAXALLY, MINALLY ) ; }
		for( i=L2_ ; i<xsize ; i++, pP++, pX++ ){ *pP = GetMedianValue( 1, (CN3), (xsize), Y, S, pX, &MAXMAX, &MINMIN, MAXALLY, MINALLY ) ; }
	}

	if( memtype==1 ){
		memcpy( pxOrg, DUMYIMG, xsize*ysize*sizeof(BYTE) ) ;
		free( MAXALLY ) ;
		free( MINALLY ) ;
		free( DUMYIMG ) ;
	}

	///////////////////
	///////////////////
	///////////////////
	// Return (TRUE).
	///////////////////
	///////////////////
	///////////////////	
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : .
//--------------------------------------------------------------------------------------
//	Input		 : PIX			: 
//				   TMP			: 
//				   NUM			: 
//--------------------------------------------------------------------------------------
//	Output		 : -
//--------------------------------------------------------------------------------------
//	Return Value : MAX			: 
//--------------------------------------------------------------------------------------
//	Date		 : 2007.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
BYTE GetMedianValue2				( BYTE *PIX,
									  BYTE *TMP,
									  LONG NUM )
{
	BYTE	MAX=0 ;
	LONG	i, j, k, CHK ;

	memset( TMP, 0, NUM*sizeof(BYTE) ) ;
	k   = NUM/2 ;
	CHK = 0 ;

	for( j=0 ; j<=k ; ){
		MAX = 0 ;
		for( i=0 ; i<NUM ; ){
			if( TMP[i]!=1 ){
				if( PIX[i]>=MAX ){
					MAX = PIX[i] ;
					CHK = i ;
				}
			}
			i++ ;
		}
		TMP[CHK] = 1 ;
		j++ ;
	}
	return ( MAX ) ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : M E D I A N  F I L T E R (3x3-non-weighted)
//--------------------------------------------------------------------------------------
//	Input		 : xsize		: width  of image data
//				   ysize		: height of image data 
//--------------------------------------------------------------------------------------
//	Output		 : pximg		: pointer of image data
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2001.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _MEDIAN_FILTER					( LONG xsize,
									  LONG ysize,
									  BYTE *pximg )
{
	LONG	i, j, X, Y ;
	BYTE	*L0, *L1, *p0, *p1, *dm, PX[9], TMP[9] ;
	ULNG	n ;

	////////////////////////////////////////
	// Check arguments and set parameters.
	////////////////////////////////////////
	if( (xsize<3)||(ysize<3)||(pximg==NULL) ){ return FALSE ; }
	X = (LONG)(xsize-1) ;
	Y = (LONG)(ysize-1) ;

	////////////////////////////////
	// Allocate memory for L0, L1.
	////////////////////////////////
	L0 = malloc( xsize*sizeof(BYTE) ) ; // MEMORY PROBLEM
	L1 = malloc( xsize*sizeof(BYTE) ) ; // MEMORY PROBLEM
	if( (L0==NULL) || (L1==NULL) ){
		return	FALSE ;
	}
	p0 = L0 ;
	p1 = L1 ;

	//////////////////////////////////
	// Processing on the first line.
	//////////////////////////////////	
	n = 0 ;
	p0[0] = _CHECK_BYTE( (SHRT)(3*pximg[n]-pximg[n+1]-pximg[n+xsize]) ) ;
	n++ ;
	for( i=1 ; i<X ; i++ ){
		p0[i] = _CHECK_BYTE( (SHRT)(((pximg[n])<<2)-pximg[n-1]-pximg[n+1]-pximg[n+xsize]) ) ;
		n++ ;
	}
	p0[i] = _CHECK_BYTE( (SHRT)(3*pximg[n]-pximg[n-1]-pximg[n+xsize]) ) ;
	n++ ;

	///////////////////////////////////////////////////////////
	// Processing on the second line to the second last line.
	///////////////////////////////////////////////////////////
	for( j=1 ; j<Y ; j++ ){
		p1[0] = _CHECK_BYTE( (SHRT)(((pximg[n])<<2)-pximg[n-xsize]-pximg[n+1]-pximg[n+xsize]) ) ;
		n++ ;
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		// Try as best as you can so that the processing speed is fast enough for the system !!
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		
		for( i=1 ; i<X ; i++ ){			
		
			PX[0] = *(pximg+(n-xsize-1)) ;
			PX[1] = *(pximg+(n-xsize  )) ;
			PX[2] = *(pximg+(n-xsize+1)) ;

			PX[3] = *(pximg+(n      -1)) ;
			PX[4] = *(pximg+(n        )) ;
			PX[5] = *(pximg+(n      +1)) ;

			PX[6] = *(pximg+(n+xsize-1)) ;
			PX[7] = *(pximg+(n+xsize  )) ;
			PX[8] = *(pximg+(n+xsize+1)) ;

			// PX[0]-PX[8]で5番目の輝度値(明るい？暗い？)を検索すればよい

			
			p1[i] = _CHECK_BYTE( (SHRT)( GetMedianValue2( PX, TMP, 9 ) ) ) ;

			//p1[i] = PX[4] ;
			

			n++ ;
		}
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		p1[i] = _CHECK_BYTE( (SHRT)(((pximg[n])<<2)-pximg[n-xsize]-pximg[n-1]-pximg[n+xsize]) ) ;
		n++ ;
		memcpy( pximg+(n-xsize-xsize), p0, xsize ) ;
		dm = p0 ;
		p0 = p1 ;
		p1 = dm ;
	}

	/////////////////////////////////
	// Processing on the last line.
	/////////////////////////////////
	p1[0] = _CHECK_BYTE( (SHRT)(3*pximg[n]-pximg[n-xsize]-pximg[n+1]) ) ;
	n++ ;
	for( i=1 ; i<X ; i++ ){
		p1[i] = _CHECK_BYTE( (SHRT)(((pximg[n])<<2)-pximg[n-xsize]-pximg[n-1]-pximg[n+1]) ) ;
		n++ ;
	}
	p1[i] = _CHECK_BYTE( (SHRT)(3*pximg[n]-pximg[n-xsize]-pximg[n-1]) ) ;
	n++ ;
	memcpy( pximg+(n-xsize-xsize), p0, xsize ) ;
	memcpy( pximg+(n-xsize), p1, xsize ) ;

	//////////////////////////
	// Free memory & return.
	//////////////////////////
	free( L0 ) ;
	free( L1 ) ;
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Smooth 8-bit image data.
//				   Based on moving average method (3x3-non-weighted).
//--------------------------------------------------------------------------------------
//	Input		 : xsize		: width  of image data
//				   ysize		: height of image data 
//--------------------------------------------------------------------------------------
//	Output		 : pximg		: pointer of image data
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2001.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _SMOOTH_IMAGE_BYTE				( LONG xsize,
									  LONG ysize,
									  BYTE *pbuff,
									  BYTE *pximg )
{
	LONG	i, j, X, Y, R0, R1, R2, BL                ;
	BYTE	*L0, *L1, *p0, *p1, *dm, *PX0, *PX1, *PX2 ;
	ULNG	tmp                                       ;

	////////////////////////////////////////
	// Check arguments and set parameters.
	////////////////////////////////////////
	if( (xsize<3)||(ysize<3)||(pximg==NULL) ){ return FALSE ; }
	X = (LONG)(xsize-1) ;
	Y = (LONG)(ysize-1) ;

	////////////////////////////////
	// Allocate memory for L0, L1.
	////////////////////////////////
	if( pbuff==NULL ){
		L0 = malloc( xsize*sizeof(BYTE) ) ;
		L1 = malloc( xsize*sizeof(BYTE) ) ;
	}
	else             {
		L0 = pbuff                        ;
		L1 = pbuff + xsize                ;
	}
	if( (L0==NULL) || (L1==NULL) ){
		return	FALSE ;
	}
	p0 = L0 ;
	p1 = L1 ;

	//////////////////////////////////
	// Processing on the first line.
	//////////////////////////////////
	R0    = (LONG)(pximg[0]+pximg[0+xsize]) ;
	R1    = (LONG)(pximg[1]+pximg[1+xsize]) ;
	BL    = (LONG)(R0+R1) ;
	p0[0] = (BYTE)(BL>>2) ;
	for( i=1 ; i<X ; i++ ){
		R2    = (LONG)(pximg[i+1]+pximg[i+1+xsize]) ;
		p0[i] = (BYTE)((BL+R2)/6) ;
		BL    = (LONG)(R1+R2) ;
		R0    = R1 ;
		R1    = R2 ;
	}
	p0[X] = (BYTE)(BL>>2) ;

	///////////////////////////////////////////////////////////
	// Processing on the second line to the second last line.
	///////////////////////////////////////////////////////////
	tmp = (ULNG)xsize ;
	for( j=1 ; j<Y ; ){
		R0    = (LONG)(pximg[tmp-xsize+0]+pximg[tmp+0]+pximg[tmp+xsize+0]) ;
		R1    = (LONG)(pximg[tmp-xsize+1]+pximg[tmp+1]+pximg[tmp+xsize+1]) ;
		BL    = (LONG)(R0+R1) ;
		p1[0] = (BYTE)(BL/6) ;
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		// Try as best as you can so that the processing speed is fast enough for the system !!
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		PX0   = pximg+(tmp+2-xsize) ;
		PX1   = pximg+(tmp+2      ) ;
		PX2   = pximg+(tmp+2+xsize) ;
		for( i=1 ; i<X ; ){
			R2    = (LONG)((*(PX0++))+(*(PX1++))+(*(PX2++))) ;
			//p1[i] = (BYTE)((BL+R2)/9) ;
			//p1[i] = (BYTE)((7*((BL+R2-(SHRT)(*(PX1-2)))>>3)+(SHRT)(*(PX1-2)))>>3) ;
			//p1[i] = (BYTE)(((BL+R2-(SHRT)(*(PX1-2))))>>3) ;
			//p1[i] = _CHECK_BYTE( (SHRT)(ABS((R2-R0))+ABS((*(PX1-xsize-3)+*(PX1-xsize-2)+*(PX1-xsize-1)-*(PX1+xsize-3)-*(PX1+xsize-2)-*(PX1+xsize-1)))) ) ;
			//p1[i] = (BYTE)_CHECK_BYTE( ( BL+R2-9*( *(PX1-2) ) ) ) ;
			p1[i] = (BYTE)(((BL+R2-(SHRT)(*(PX1-2))))>>3) ;
			//p1[i] = (BYTE)((((BL+R2-(*(PX1-2)))>>3)+(*(PX1-2)))>>1) ; // 重み付け
			BL    = (LONG)(R1+R2) ;
			R0    = R1 ;
			R1    = R2 ;
			i++ ;
		}
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		p1[X] = (BYTE)(BL/6) ;
		memcpy( pximg+tmp-xsize, p0, xsize ) ;
		dm = p0 ;
		p0 = p1 ;
		p1 = dm ;
		tmp += (ULNG)xsize ;
		j++ ;
	}

	/////////////////////////////////
	// Processing on the last line.
	/////////////////////////////////
	R0    = (LONG)(pximg[tmp-xsize+0]+pximg[tmp+0]) ;
	R1    = (LONG)(pximg[tmp-xsize+1]+pximg[tmp+1]) ;
	BL    = (LONG)(R0+R1) ;
	p1[0] = (BYTE)(BL>>2) ;
	for( i=1 ; i<X ; i++ ){
		R2    = (LONG)(pximg[tmp-xsize+(i+1)]+pximg[tmp+(i+1)]) ;
		p1[i] = (BYTE)((BL+R2)/6) ;
		BL    = (LONG)(R1+R2) ;
		R0    = R1 ;
		R1    = R2 ;
	}
	p1[X] = (BYTE)(BL>>2) ;
	memcpy( pximg+tmp-xsize, p0, xsize ) ;
	memcpy( pximg+tmp, p1, xsize ) ;

	//////////////////////////
	// Free memory & return.
	//////////////////////////
	if( pbuff==NULL ){
		free( L0 ) ;
		free( L1 ) ;
	}
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Smooth 32bit image data.
//				   Based on moving average method (3x3-non-weighted).
//--------------------------------------------------------------------------------------
//	Input		 : xsize		: width  of image data
//				   ysize		: height of image data 
//--------------------------------------------------------------------------------------
//	Output		 : pximg		: pointer of image data
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2001.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _SMOOTH_IMAGE_LONG				( LONG xsize,
									  LONG ysize,
									  LONG *pbuff,
									  LONG *pximg )
{
	LONG	i, j, X, Y, R0, R1, R2, BL                ;
	LONG	*L0, *L1, *p0, *p1, *dm, *PX0, *PX1, *PX2 ;
	ULNG	tmp, size                                 ;

	////////////////////////////////////////
	// Check arguments and set parameters.
	////////////////////////////////////////
	if( (xsize<3)||(ysize<3)||(pximg==NULL) ){ return FALSE ; }
	X    = (LONG)(xsize-1)    ;
	Y    = (LONG)(ysize-1)    ;
	size = xsize*sizeof(LONG) ;

	////////////////////////////////
	// Allocate memory for L0, L1.
	////////////////////////////////
	if( pbuff==NULL ){
		L0 = malloc( size ) ;
		L1 = malloc( size ) ;
	}
	else             {
		L0 = pbuff          ;
		L1 = pbuff + xsize  ;
	}
	if( (L0==NULL) || (L1==NULL) ){
		return	FALSE ;
	}
	p0 = L0 ;
	p1 = L1 ;

	//////////////////////////////////
	// Processing on the first line.
	//////////////////////////////////
	R0    = pximg[0]+pximg[0+xsize] ;
	R1    = pximg[1]+pximg[1+xsize] ;
	BL    = R0+R1 ;
	p0[0] = BL>>2 ;
	for( i=1 ; i<X ; i++ ){
		R2    = pximg[i+1]+pximg[i+1+xsize] ;
		p0[i] = (BL+R2)/6 ;
		BL    = R1+R2 ;
		R0    = R1 ;
		R1    = R2 ;
	}
	p0[X] = BL>>2 ;

	///////////////////////////////////////////////////////////
	// Processing on the second line to the second last line.
	///////////////////////////////////////////////////////////
	tmp = (ULNG)xsize ;
	for( j=1 ; j<Y ; ){
		R0    = pximg[tmp-xsize+0]+pximg[tmp+0]+pximg[tmp+xsize+0] ;
		R1    = pximg[tmp-xsize+1]+pximg[tmp+1]+pximg[tmp+xsize+1] ;
		BL    = R0+R1 ;
		p1[0] = BL/6  ;
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		// Try as best as you can so that the processing speed is fast enough for the system !!
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		PX0   = pximg+(tmp+2-xsize) ;
		PX1   = pximg+(tmp+2      ) ;
		PX2   = pximg+(tmp+2+xsize) ;
		for( i=1 ; i<X ; ){
			R2    = *(PX0++) + *(PX1++) + *(PX2++) ;
			//p1[i] = (LONG)((BL+R2)/9)                                             ;
			//p1[i] = (LONG)((7*((BL+R2-(SHRT)(*(PX1-2)))>>3)+(SHRT)(*(PX1-2)))>>3) ;
			//p1[i] = (LONG)(((BL+R2-(SHRT)(*(PX1-2))))>>3)                         ;
			p1[i] = (((BL+R2-(*(PX1-2)))>>3)+(*(PX1-2)))>>1 ; // 重み付け
			BL    = R1+R2 ;
			R0    = R1 ;
			R1    = R2 ;
			i++ ;
		}
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		p1[X] = BL/6 ;
		memcpy( pximg+tmp-xsize, p0, size ) ;
		dm = p0 ;
		p0 = p1 ;
		p1 = dm ;
		tmp += (ULNG)xsize ;
		j++ ;
	}

	/////////////////////////////////
	// Processing on the last line.
	/////////////////////////////////
	R0    = pximg[tmp-xsize+0]+pximg[tmp+0] ;
	R1    = pximg[tmp-xsize+1]+pximg[tmp+1] ;
	BL    = R0+R1 ;
	p1[0] = BL>>2 ;
	for( i=1 ; i<X ; i++ ){
		R2    = pximg[tmp-xsize+(i+1)]+pximg[tmp+(i+1)] ;
		p1[i] = (BL+R2)/6 ;
		BL    = R1+R2 ;
		R0    = R1 ;
		R1    = R2 ;
	}
	p1[X] = BL>>2 ;
	memcpy( pximg+tmp-xsize, p0, size ) ;
	memcpy( pximg+tmp,       p1, size ) ;

	//////////////////////////
	// Free memory & return.
	//////////////////////////
	if( pbuff==NULL ){
		free( L0 ) ;
		free( L1 ) ;
	}
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Sharpen 8-bit image data.
//				   Based on 2-D Laplacian operation (3x3-non-weighted).
//--------------------------------------------------------------------------------------
//	Input		 : xsize		: width  of image data
//				   ysize		: height of image data 
//--------------------------------------------------------------------------------------
//	Output		 : pximg		: pointer of image data
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2001.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _SHARPN_IMAGE					( LONG xsize,
									  LONG ysize,
									  BYTE *pximg )
{
	LONG	i, j, X, Y ;
	BYTE	*L0, *L1, *p0, *p1, *dm, *PX0, *PX1, *PX2, *PX3, *PX4 ;
	ULNG	n ;

	////////////////////////////////////////
	// Check arguments and set parameters.
	////////////////////////////////////////
	if( (xsize<3)||(ysize<3)||(pximg==NULL) ){ return FALSE ; }
	X = (LONG)(xsize-1) ;
	Y = (LONG)(ysize-1) ;

	////////////////////////////////
	// Allocate memory for L0, L1.
	////////////////////////////////
	L0 = malloc( xsize*sizeof(BYTE) ) ;
	L1 = malloc( xsize*sizeof(BYTE) ) ;
	if( (L0==NULL) || (L1==NULL) ){
		return	FALSE ;
	}
	p0 = L0 ;
	p1 = L1 ;

	//////////////////////////////////
	// Processing on the first line.
	//////////////////////////////////	
	n = 0 ;
	p0[0] = _CHECK_BYTE( (SHRT)(3*pximg[n]-pximg[n+1]-pximg[n+xsize]) ) ;
	n++ ;
	for( i=1 ; i<X ; i++ ){
		p0[i] = _CHECK_BYTE( (SHRT)(((pximg[n])<<2)-pximg[n-1]-pximg[n+1]-pximg[n+xsize]) ) ;
		n++ ;
	}
	p0[i] = _CHECK_BYTE( (SHRT)(3*pximg[n]-pximg[n-1]-pximg[n+xsize]) ) ;
	n++ ;

	///////////////////////////////////////////////////////////
	// Processing on the second line to the second last line.
	///////////////////////////////////////////////////////////
	for( j=1 ; j<Y ; j++ ){
		p1[0] = _CHECK_BYTE( (SHRT)(((pximg[n])<<2)-pximg[n-xsize]-pximg[n+1]-pximg[n+xsize]) ) ;
		n++ ;
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		// Try as best as you can so that the processing speed is fast enough for the system !!
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		PX0 = pximg+(n-xsize) ;
		PX1 = pximg+(n-1    ) ;
		PX2 = pximg+(n      ) ;
		PX3 = pximg+(n+1    ) ;
		PX4 = pximg+(n+xsize) ;
		for( i=1 ; i<X ; i++ ){			
			p1[i] = _CHECK_BYTE( (SHRT)(5*(*(PX2++))-(*(PX0++))-(*(PX1++))-(*(PX3++))-(*(PX4++))) ) ;
			n++ ;
		}
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		/////////////////////////////////////////////////////////////////////////////////////////
		p1[i] = _CHECK_BYTE( (SHRT)(((pximg[n])<<2)-pximg[n-xsize]-pximg[n-1]-pximg[n+xsize]) ) ;
		n++ ;
		memcpy( pximg+(n-xsize-xsize), p0, xsize ) ;
		dm = p0 ;
		p0 = p1 ;
		p1 = dm ;
	}

	/////////////////////////////////
	// Processing on the last line.
	/////////////////////////////////
	p1[0] = _CHECK_BYTE( (SHRT)(3*pximg[n]-pximg[n-xsize]-pximg[n+1]) ) ;
	n++ ;
	for( i=1 ; i<X ; i++ ){
		p1[i] = _CHECK_BYTE( (SHRT)(((pximg[n])<<2)-pximg[n-xsize]-pximg[n-1]-pximg[n+1]) ) ;
		n++ ;
	}
	p1[i] = _CHECK_BYTE( (SHRT)(3*pximg[n]-pximg[n-xsize]-pximg[n-1]) ) ;
	n++ ;
	memcpy( pximg+(n-xsize-xsize), p0, xsize ) ;
	memcpy( pximg+(n-xsize), p1, xsize ) ;

	//////////////////////////
	// Free memory & return.
	//////////////////////////
	free( L0 ) ;
	free( L1 ) ;
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : De-interlace processing.
//--------------------------------------------------------------------------------------
//	Input		 : type			: stop(0), odd(1) or even(2)
//				   xsize		: width  of image data
//				   ysize		: height of image data 
//--------------------------------------------------------------------------------------
//	Output		 : pximg		: pointer of image data
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2002.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _INTERLACE_PROC				( BYTE type,
									  LONG xsize,
									  LONG ysize,
									  BYTE *pximg )
{
	LONG	i, j, X, Y, Y2, Z ;
	LONG	R0, R1, R2 ;
	BYTE	flag ;
	ULNG	tmp ;

	////////////////////////////////////////
	// Check arguments and set parameters.
	////////////////////////////////////////
	if( (xsize<3)||(ysize<3)||(pximg==NULL) ){ return FALSE ; }
	if( type==0 ){ return TRUE  ; }
	if( type>=3 ){ return FALSE ; }
	X  = (LONG)(xsize-1) ;
	Y  = (LONG)(ysize-1) ;
	Z  = (LONG)(2*xsize) ;
	if( (ysize%2)==0 ){	// even number
		flag = 0 ;
		if( type==2 ){ Y2 = (LONG)(ysize/2-1) ; }
		else         { Y2 = (LONG)(ysize/2-1) ; }
	}
	else{				// odd  number
		flag = 1 ;
		if( type==2 ){ Y2 = (LONG)(ysize/2  ) ; }
		else         { Y2 = (LONG)(ysize/2-1) ; }
	}

	//////////////////////////////////
	// Processing on the first line.
	//////////////////////////////////
	if( type==2 ){
		tmp = 0 ;
	}
	else{
		tmp = (ULNG)xsize ;
		for( i=0 ; i<xsize ; i++ ){
			pximg[i] = (BYTE)(pximg[i+xsize]) ;
		}
	}

	//////////////////////////////////////////
	// Processing on the second(third) line.
	//////////////////////////////////////////
	tmp       += (ULNG)xsize ;
	R0         = (LONG)(pximg[tmp-xsize+0]+pximg[tmp+xsize+0]) ;
	R1         = (LONG)(pximg[tmp-xsize+1]+pximg[tmp+xsize+1]) ;
	pximg[tmp] = (BYTE)((3*R0+R1)>>3) ;
	for( i=1 ; i<X ; i++ ){
		R2           = (LONG)(pximg[tmp-xsize+1+i]+pximg[tmp+xsize+1+i]) ;
		pximg[tmp+i] = (BYTE)((R0+2*R1+R2)>>3) ;
		R0           = R1 ;
		R1           = R2 ;
	}
	pximg[tmp+X] = (BYTE)((R0+3*R1)>>3) ;

	

	/////////////////////////////////////////////////////////////
	// Processing on the fourth line to the (second) last line.
	/////////////////////////////////////////////////////////////
	tmp  += (ULNG)(2*xsize) ;
	for( j=1 ; j<Y2 ; j++ ){	
		R0         = (LONG)(pximg[tmp-xsize+0]+pximg[tmp+xsize+0]) ;
		R1         = (LONG)(pximg[tmp-xsize+1]+pximg[tmp+xsize+1]) ;
		pximg[tmp] = (BYTE)((3*R0+R1)>>3) ;
		for( i=1 ; i<X ; i++ ){
			R2           = (LONG)(pximg[tmp-xsize+1+i]+pximg[tmp+xsize+1+i]) ;
			pximg[tmp+i] = (BYTE)((R0+14*R1+R2)>>5) ;
			//pximg[tmp+i] = (BYTE)((R0+2*R1+R2)>>3) ;
			//pximg[tmp+i] = (BYTE)((R0+6*R1+R2)>>4) ;
			//pximg[tmp+i] = (BYTE)(R1>>1) ;
			R0           = R1 ;
			R1           = R2 ;
		}
		pximg[tmp+X] = (BYTE)((R0+3*R1)>>3) ;
		tmp += (ULNG)(2*xsize) ;	
	}

	/////////////////////////////////
	// Processing on the last line.
	/////////////////////////////////
	if     ( (type==2)&&(flag==0) ){
		for( i=0 ; i<xsize ; i++ ){
			pximg[tmp+i] = (BYTE)(pximg[tmp+i-xsize]) ;
		}
	}

	else if( (type==1)&&(flag==1) ){
		for( i=0 ; i<xsize ; i++ ){
			pximg[tmp+i] = (BYTE)(pximg[tmp+i-xsize]) ;
		}
	}

	////////////////////
	// Return TRUE(1).
	////////////////////
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Search objects(characters) or background in the image data,
//				   then fat them just one pixel. 
//--------------------------------------------------------------------------------------
//	Input		 : xsize		: width  of image data
//				   ysize		: height of image data
//				   flag			: 0:fat(or delete) black pixel(pixel value:  0)
//								  1:fat(or delete) white pixel(pixel value:255)
//				   type			: filter type
//								  0:strong
//								  1:normal
//								  2:vertical
//								  3:horizontal
//				   rect			: pointer of "RCTN" (target area) 
//				   pximg		: binarized 8bit-image data (input)
//--------------------------------------------------------------------------------------
//	Output		 : pximg		: binarized 8bit-image data (output)
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2005.06.06
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _FAT_OBJECT					( LONG xsize,
									  LONG ysize,
									  BYTE flag,
									  BYTE type,
									  RCTN *rect,
									  BYTE *pximg )
{
	LONG	i, j ;
	LONG	X, Y ;
	BYTE	BW, BW_, CH=128 ;
	BYTE	*p1, *p2, *d1, *d2, *d3, c ;

	/////////////////////
	// Check arguments. 
	/////////////////////
	if( flag>1      ){ return FALSE ; }
	if( xsize<3     ){ return FALSE ; }
	if( ysize<3     ){ return FALSE ; }
	if( rect==NULL  ){ return FALSE ; }
	if( pximg==NULL ){ return FALSE ; }
	if( (rect->sx<0)||(rect->sx>=xsize)||(rect->ex<0)||(rect->ex>=xsize) ){ return FALSE ; }
	if( (rect->sy<0)||(rect->sy>=ysize)||(rect->ey<0)||(rect->ey>=ysize) ){ return FALSE ; }
	if( (rect->sx>rect->ex)||(rect->sy>rect->ey) ){ return FALSE ; }

	//////////////////////////////////////////////////////////
	// Check each pixel value and fat objects or background.
	//////////////////////////////////////////////////////////
	BW  = (BYTE)(PXMAX*flag) ;
	BW_ = (BYTE)(PXMAX*(1-flag)) ;
	X   = (LONG)(rect->ex-rect->sx+1-2) ;
	Y   = (LONG)(rect->ey-rect->sy+1-2) ;
	p1  = pximg+(xsize*(rect->sy+1)+(rect->sx+1)) ;

	switch( type ){
		case 0:
			for( j=0 ; j<Y ; j++ ){
				p2 = p1 ;
				d1 = p2-xsize-1 ;
				d2 = p2      -1 ;
				d3 = p2+xsize-1 ;
				for( i=0 ; i<X ; i++, p2++, d1++, d2++, d3++ ){
					if( (*p2)==BW ){
						c = (BYTE)( (*d1!=BW)+(*d2!=BW)+(*d3!=BW)+(*(d1+1)!=BW)+(*(d3+1)!=BW)+(*(d1+2)!=BW)+(*(d2+2)!=BW)+(*(d3+2)!=BW) ) ;
						if( c>=2 ){
							if( (*(p2-xsize  ))!=BW ){ (*(p2-xsize  )) = CH ; }
							if( (*(p2      -1))!=BW ){ (*(p2      -1)) = CH ; }
							if( (*(p2      +1))!=BW ){ (*(p2      +1)) = CH ; }
							if( (*(p2+xsize  ))!=BW ){ (*(p2+xsize  )) = CH ; }
							if( (*(p2-xsize-1))!=BW ){ (*(p2-xsize-1)) = CH ; }
							if( (*(p2-xsize+1))!=BW ){ (*(p2-xsize+1)) = CH ; }
							if( (*(p2+xsize-1))!=BW ){ (*(p2+xsize-1)) = CH ; }
							if( (*(p2+xsize+1))!=BW ){ (*(p2+xsize+1)) = CH ; }
						}
					}
				}
				p1 += xsize ;
			}
			break ;
		case 1:
			for( j=0 ; j<Y ; j++ ){
				p2 = p1 ;
				d1 = p2-xsize-1 ;
				d2 = p2      -1 ;
				d3 = p2+xsize-1 ;
				for( i=0 ; i<X ; i++, p2++, d1++, d2++, d3++ ){
					if( (*p2)==BW ){
						c = (BYTE)( (*d1!=BW)+(*d2!=BW)+(*d3!=BW)+(*(d1+1)!=BW)+(*(d3+1)!=BW)+(*(d1+2)!=BW)+(*(d2+2)!=BW)+(*(d3+2)!=BW) ) ;
						if( c>=2 ){
							if( (*(p2-xsize  ))!=BW ){ (*(p2-xsize  )) = CH ; }
							if( (*(p2      -1))!=BW ){ (*(p2      -1)) = CH ; }
							if( (*(p2      +1))!=BW ){ (*(p2      +1)) = CH ; }
							if( (*(p2+xsize  ))!=BW ){ (*(p2+xsize  )) = CH ; }
						}
					}
				}
				p1 += xsize ;
			}
			break ;
		case 2:
			for( j=0 ; j<Y ; j++ ){
				p2 = p1 ;
				d1 = p2-xsize-1 ;
				d2 = p2      -1 ;
				d3 = p2+xsize-1 ;
				for( i=0 ; i<X ; i++, p2++, d1++, d2++, d3++ ){
					if( (*p2)==BW ){
						c = (BYTE)( (*d1!=BW)+(*d2!=BW)+(*d3!=BW)+(*(d1+1)!=BW)+(*(d3+1)!=BW)+(*(d1+2)!=BW)+(*(d2+2)!=BW)+(*(d3+2)!=BW) ) ;
						if( c>=2 ){
							if( (*(p2-xsize  ))!=BW ){ (*(p2-xsize  )) = CH ; }
							if( (*(p2+xsize  ))!=BW ){ (*(p2+xsize  )) = CH ; }
							//if( (*(p2-xsize-1))!=BW ){ (*(p2-xsize-1)) = CH ; }
							//if( (*(p2-xsize+1))!=BW ){ (*(p2-xsize+1)) = CH ; }
							//if( (*(p2+xsize-1))!=BW ){ (*(p2+xsize-1)) = CH ; }
							//if( (*(p2+xsize+1))!=BW ){ (*(p2+xsize+1)) = CH ; }
						}
					}
				}
				p1 += xsize ;
			}
			break ;
		case 3:
			for( j=0 ; j<Y ; j++ ){
				p2 = p1 ;
				d1 = p2-xsize-1 ;
				d2 = p2      -1 ;
				d3 = p2+xsize-1 ;
				for( i=0 ; i<X ; i++, p2++, d1++, d2++, d3++ ){
					if( (*p2)==BW ){
						c = (BYTE)( (*d1!=BW)+(*d2!=BW)+(*d3!=BW)+(*(d1+1)!=BW)+(*(d3+1)!=BW)+(*(d1+2)!=BW)+(*(d2+2)!=BW)+(*(d3+2)!=BW) ) ;
						if( c>=2 ){
							if( (*(p2      -1))!=BW ){ (*(p2      -1)) = CH ; }
							if( (*(p2      +1))!=BW ){ (*(p2      +1)) = CH ; }
							//if( (*(p2-xsize-1))!=BW ){ (*(p2-xsize-1)) = CH ; }
							//if( (*(p2-xsize+1))!=BW ){ (*(p2-xsize+1)) = CH ; }
							//if( (*(p2+xsize-1))!=BW ){ (*(p2+xsize-1)) = CH ; }
							//if( (*(p2+xsize+1))!=BW ){ (*(p2+xsize+1)) = CH ; }
						}
					}
				}
				p1 += xsize ;
			}
			break ;
		default:
			return FALSE ;
	}
	X  = (LONG)(rect->ex-rect->sx+1) ;
	Y  = (LONG)(rect->ey-rect->sy+1) ;
	p1 = pximg+(xsize*rect->sy+rect->sx) ;
	for( j=0 ; j<Y ; j++ ){
		p2 = p1 ;
		for( i=0 ; i<X ; i++ ){
			if( (*p2)==CH ){ *p2 = BW ; }
			p2++ ;
		}
		p1 += xsize ;
	}

	////////////////////
	// Return TRUE(1).
	////////////////////
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Search objects(characters) or background in the image data,
//				   then fat them just one pixel. 
//--------------------------------------------------------------------------------------
//	Input		 : xsize		: width  of image data
//				   ysize		: height of image data
//				   flag			: 0:
//								  1:
//								  2:
//								  3:
//				   vari			: variable for "FUNC"
//				   BW_			: background level
//				   type			: filter type
//								  0:delete beard(vertical)
//								  1:delete beard(horizontal)
//				   rect			: pointer of "RCTN" (target area) 
//				   pximg		: binarized 8bit-image data (input)
//--------------------------------------------------------------------------------------
//	Output		 : pximg		: binarized 8bit-image data (output)
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2005.06.06
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _CUT_BEARDLINE					( LONG xsize,
									  LONG ysize,
									  BYTE flag,
									  BYTE vari,
									  BYTE BW_,
									  BYTE type,
									  RCTN *rect,
									  BYTE *pximg )
{
	LONG	i, j ;
	LONG	X, Y ;
	BYTE	*p1, *p2, c ;
	FUNC	func ;

	switch( flag ){
		case 0:
			func = CHK0 ;
			break ;
		case 1:
			func = CHK1 ;
			break ;
		case 2:
			func = CHK2 ;
			break ;
		case 3:
			func = CHK3 ;
			break ;
		default:
			return FALSE ;
			break ;
	}
	
	/////////////////////
	// Check arguments. 
	/////////////////////
	if( flag>1      ){ return FALSE ; }
	if( xsize<3     ){ return FALSE ; }
	if( ysize<3     ){ return FALSE ; }
	if( rect==NULL  ){ return FALSE ; }
	if( pximg==NULL ){ return FALSE ; }
	if( (rect->sx<0)||(rect->sx>=xsize)||(rect->ex<0)||(rect->ex>=xsize) ){ return FALSE ; }
	if( (rect->sy<0)||(rect->sy>=ysize)||(rect->ey<0)||(rect->ey>=ysize) ){ return FALSE ; }
	if( (rect->sx>rect->ex)||(rect->sy>rect->ey) ){ return FALSE ; }

	//////////////////////////////////////////////////////////
	// Check each pixel value and fat objects or background.
	//////////////////////////////////////////////////////////
	//BW  = (BYTE)(PXMAX*flag) ;
	//BW_ = (BYTE)(PXMAX*(1-flag)) ;
	X   = (LONG)(rect->ex-rect->sx+1-2) ;
	Y   = (LONG)(rect->ey-rect->sy+1-2) ;
	p1  = pximg+(xsize*(rect->sy+1)+(rect->sx+1)) ;

	switch( type ){
		case 0:
			X   = (LONG)(rect->ex-rect->sx+1) ;
			Y   = (LONG)(rect->ey-rect->sy+1) ;
			p1  = pximg+(xsize*rect->sy+rect->sx) ;
			for( j=0 ; j<Y ; j++ ){
				p2 = p1 ;
				c  = 0 ;
				for( i=0 ; i<X ; i++ ){
					if( func( p2, vari ) ){
				////if( (*p2)!=BW_ ){
						if     ( c==0 ){ c = 1 ; }
						else if( c==1 ){ c = 2 ; }
					}
					else{
						if( c==1 ){
							*(p2-1) = BW_ ; // change to white(black) background pixel value
							c = 0 ;
						}
						else if( c==2 ){ c = 0 ; }
					}
					p2++ ;
				}
				p1 += xsize ;
			}
			break ;
		case 1:
			X   = (LONG)(rect->ex-rect->sx+1) ;
			Y   = (LONG)(rect->ey-rect->sy+1) ;
			p1  = pximg+(xsize*rect->sy+rect->sx) ;
			for( i=0 ; i<X ; i++ ){
				p2 = p1 ;
				c  = 0 ;
				for( j=0 ; j<Y ; j++ ){
					if( func( p2, vari ) ){
				////if( (*p2)!=BW_ ){
						if     ( c==0 ){ c = 1 ; }
						else if( c==1 ){ c = 2 ; }
						//(*p2)=BW_;
					}
					else{
						if( c==1 ){
							*(p2-xsize) = BW_ ; // change to white(black) background pixel value
							c = 0 ;
						}
						else if( c==2 ){ c = 0 ; }
					}
					p2 += xsize ;
				}
				p1++ ;
			}
			break ;
		default:
			return FALSE ;
	}

	////////////////////
	// Return TRUE(1).
	////////////////////
	return TRUE ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : .
//--------------------------------------------------------------------------------------
//	Input		 : xsize		: 
//				   ysize		: 
//				   orgimg		: 
//--------------------------------------------------------------------------------------
//	Output		 : difimg		: 
//--------------------------------------------------------------------------------------
//	Return Value : TRUE(1)		: success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2007.11.10
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
CHAR _DIFFER_IMAGE					( LONG xsize,
									  LONG ysize,
									  BYTE *orgimg,
									  BYTE *difimg )
{
	LONG	i, j, X, Y ;
	BYTE	*p0, *p1, *pL, *pR, *pU, *pB ;
	BYTE	dx, dy ;

	BYTE	dxy0, dxy1, dxy2, dxy3 ;
	
	BYTE	dxy2da, dxy2db ;

	BYTE	DIF, MAX, MIN, DD ;

	////////////////////////////////////////
	// Check arguments and set parameters.
	////////////////////////////////////////
	if( (xsize<3)||(ysize<3)||(orgimg==NULL)||(difimg==NULL) ){ return FALSE ; }


	DD = 1 ;

	X  = (LONG)(xsize-DD)  ;
	Y  = (LONG)(ysize-DD)  ;

	p0 = orgimg+(DD*xsize+DD) ;
	p1 = difimg+(DD*xsize+DD) ;

	for( j=DD ; j<Y ; ){
	
		pL = p0-DD       ;
		pR = p0+DD       ;
		pU = p0-DD*xsize ;
		pB = p0+DD*xsize ;
		
		for( i=DD ; i<X ; ){
		
			dx  = (BYTE)ABS(((BOOL)((*pR)-(*pL)))) ;
			dy  = (BYTE)ABS(((BOOL)((*pB)-(*pU)))) ;
			
			dxy0 = dx ;
			MAX=MIN=(BYTE)dx;

			dxy1 = dy ;
			if     ( dxy1>MAX ){ MAX=dxy1; }
			else if( dxy1<MIN ){ MIN=dxy1; }
			dxy2 = (BYTE)ABS( ((*(pU-DD))-(*(pB+DD))) ) ;
			
			if     ( dxy2>MAX ){ MAX=dxy2; }
			else if( dxy2<MIN ){ MIN=dxy2; }
			dxy3 = (BYTE)ABS( ((*(pB-DD))-(*(pU+DD))) ) ;
			
			if     ( dxy3>MAX ){ MAX=dxy3; }
			else if( dxy3<MIN ){ MIN=dxy3; }
			/*
			dxy0 = ABS( ((*(pL  ))-(*(p1  ))) ) + ABS( ((*(pR  ))-(*(p1  ))) ) ;
			dxy1 = ABS( ((*(pB  ))-(*(p1  ))) ) + ABS( ((*(pU  ))-(*(p1  ))) ) ;
			dxy2 = ABS( ((*(pU-1))-(*(p1  ))) ) + ABS( ((*(pB+1))-(*(p1  ))) ) ;
			dxy3 = ABS( ((*(pB-1))-(*(p1  ))) ) + ABS( ((*(pU+1))-(*(p1  ))) ) ;
			*/
			////////////////////////////////////////////
			////////////////////////////////////////////
			////////////////////////////////////////////
			//*p1 = (BYTE)(PXMAX-_CHECK_BYTE((SHRT)(ABS(dx)+ABS(dy)))) ;
			//*p1 = (BYTE)(_CHECK_BYTE((SHRT)(dx+dy))) ;
			
			*p1 = (BYTE)(_CHECK_BYTE((SHRT)(255-dxy0+dxy1+dxy2+dxy3))) ;

			//*p1 = MAX-MIN ;

			if( i==374 && j==200 ){
				//DIF = 16 ;
			}

			DIF = 32 ;

			dxy2da = (BYTE)ABS( ((*(pU-DD))-(*(p0))) ) ;
			dxy2db = (BYTE)ABS( ((*(pB+DD))-(*(p0))) ) ;

			if( (MIN==dxy2)    && (dxy2da>DIF/2) && (dxy2db>DIF/2) &&
				(dxy0>4*MAX/8) && (dxy0>DIF) &&
				(dxy1>4*MAX/8) && (dxy1>DIF) &&
				(dxy3>4*MAX/8) && (dxy3>DIF) &&
				(dxy2<2*MAX/8) ){

				*p1 = PXMAX ;
			}

			else if( (MIN==dxy1)    && 
				(dxy0>4*MAX/8) && (dxy0>DIF) &&
				(dxy2>4*MAX/8) && (dxy2>DIF) &&
				(dxy3>4*MAX/8) && (dxy3>DIF) &&
				(dxy1<2*MAX/8) ){

				//*p1 = PXMAX ;
			}

			else if( (MIN==dxy3)    && 
				(dxy0>4*MAX/8) && (dxy0>DIF) &&
				(dxy1>4*MAX/8) && (dxy1>DIF) &&
				(dxy2>4*MAX/8) && (dxy2>DIF) &&
				(dxy3<2*MAX/8) ){

				//*p1 = PXMAX ;
			}

			else if( (MIN==dxy0)    && 
				(dxy1>4*MAX/8) && (dxy1>DIF) &&
				(dxy2>4*MAX/8) && (dxy2>DIF) &&
				(dxy3>4*MAX/8) && (dxy3>DIF) &&
				(dxy0<2*MAX/8) ){

				//*p1 = PXMAX ;
			}


			
			
			
			//if( *p1<60 ){ *p1 = PXMIN ; }
			
			//else if( (dx>84)&&(dy>84) ){ *p1 = PXMAX ; }
			//else{ *p1 = PXMIN ; }
			//else        { *p1 = PXMAX ; }

			/*
			if( *p1>*(p1-1)       ){ *(p1-1)       = PXMAX ; }
			else                   { *p1           = PXMAX ; }
			if( *p1>*(p1-xsize)   ){ *(p1-xsize)   = PXMAX ; }
			else                   { *p1           = PXMAX ; }
			if( *p1>*(p1-xsize-1) ){ *(p1-xsize-1) = PXMAX ; }
			else                   { *p1           = PXMAX ; }
			if( *p1>*(p1-xsize+1) ){ *(p1-xsize+1) = PXMAX ; }
			else                   { *p1           = PXMAX ; }
			//*/


			//if( *p1<16 ){ *p1 = PXMIN ; }
			////////////////////////////////////////////
			////////////////////////////////////////////
			////////////////////////////////////////////
			p0++ ;
			p1++ ;
			pL++ ;
			pR++ ;
			pU++ ;
			pB++ ;
			i++  ;
		}

		p0 += 2*DD ;
		p1 += 2*DD ;

		j++ ;
	}



	return TRUE ;
}

/*	End of File //////////////////////////////////////////////////////////////////////*/
