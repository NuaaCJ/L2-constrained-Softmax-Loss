/***************************************************************************************
//
//		DIGITAL SIGNAL Processing Library (DSPLib)
//
//		DSPLib Main Functions.
//
//		Copyright	:: TAMAXI CORPORATION
//		Date        :: 2020.02.19
//		CPU			:: **
//		Language	:: C,C++
//		File Name	:: DSPLIB.c
//
***************************************************************************************/

/*//////////////////////////////////////////////////////////////////////////////////////
//		Definitions & Header Files
//////////////////////////////////////////////////////////////////////////////////////*/
#define		CPLUSPLUS
/*
#define		_PSC_HASP_KEY_								// HASPｷｰ ﾌﾟﾛﾃｸﾄｵﾝ
//*/
/*
#define		_RECOGLOG									// ﾌﾟﾘﾌﾟﾛｾｯｻ定義 ﾛｸﾞ出力
//*/
#define		_FOPEN				fopen
#define		_FPRINTF			fprintf
#define		_FCLOSE				fclose
#define		_LOG_TEXT			"log.txt"				// ログ出力先ファイル
#define		_MEMSIZEMARGIN		( 51200 )				// ﾒﾓﾘｻｲｽﾞﾏｰｼﾞﾝ50KB

/*//////////////////////////////////////////
//		Very Basic Header Files
//////////////////////////////////////////*/
#include	"_system.h"
#include	"_define.h"

/*//////////////////////////////////////////
//		Common Header Files
//////////////////////////////////////////*/
#include	"_dip.h"
#include	"_dip_blck.h"
#include	"_dip_binr.h"
#include	"_dip_bmap.h"
#include	"_dip_cnst.h"
#include	"_dip_labl.h"

/*//////////////////////////////////////////
//		Headers for each unique purpose
//////////////////////////////////////////*/
#include	"_dsp.h"
#include	"_dsp_cnst.h"
#include	"PSMLIB.h"
#include	"DSPLIB.h"

/*//////////////////////////////////////////////////////////////////////////////////////
//		Global Variables
//////////////////////////////////////////////////////////////////////////////////////*/
#ifdef	_RECOGLOG
static FILE*			WFP             ;
#endif//_RECOGLOG

/*//////////////////////////////////////////////////////////////////////////////////////
//		Global Functions
//////////////////////////////////////////////////////////////////////////////////////*/

/*//////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
//	オ ブ ジ ェ ク ト 認 識 ラ イ ブ ラ リ 専 用 コ ー ド - start -
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////*/

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Get worksize value.
//				   オブジェクト認識ライブラリ公開関数(ワークサイズ取得関数)
//--------------------------------------------------------------------------------------
//	Input		 : dsConfig		: 設定パラメータ
//--------------------------------------------------------------------------------------
//	Output		 : worksize		: ワークサイズ
//--------------------------------------------------------------------------------------
//	Return Value : PSERR_TRUE(0): success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2020.01.11
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
BOOL DLLEXPORT	DSP_GetWorkSize		( DSPConfig	*dsConfig	,
									  ULNG		*worksize	)
{
	BOOL		ret=PSERR_TRUE								;
	BOOL		i, j, k										;
	LONG		sz[32], imagSiz								; // 仮
	BLCK		block										; // 仮

	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Write "START" message.
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	#ifdef	_RECOGLOG
	WFP = _FOPEN( _LOG_TEXT, "a" )							;
	if( WFP!=NULL ){
		_FPRINTF( WFP, "DSP_GetWorkSize START\n" )			;
		_FCLOSE ( WFP )										;
	}
	#endif//_RECOGLOG
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Pointer NULL check.
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	if( dsConfig==NULL || worksize==NULL ){
		return PSERR_ARGU									;
	}
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Check all parameters and argument.
	// 画像ｻｲｽﾞﾁｪｯｸ
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	j = DSPIMG_SIZESET ;
	for( i=0 ; i<DSPIMG_SIZESET ; i++ ){
		if( dsConfig->xsize==DSPIMG_WID[i] && dsConfig->ysize==DSPIMG_HEI[i] ){
			j = i											;
			break											;
		}
	}
	if( j==DSPIMG_SIZESET ){
		////return PSERR_IMAG									;
	}
	if( dsConfig->depth!=8 && dsConfig->depth!=24 ){
		return PSERR_IMAG									;
	}
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Calculate total WORK SIZE
	// ﾜｰｸｻｲｽﾞを求める
	// ﾌﾞﾛｯｸ計算	: InitBlockBuffSiz
	// 輪郭追跡		: _INIT_CONNECT_COMP_SIZ
	// を使う
	// _xxx_init.c とリンクしていないと駄目
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	j		= 0												;
	sz[j++] = MEM_ALN( sizeof(DIPPARAM)					)	; // グローバル変数
	sz[j++] = MEM_ALN( sizeof(DIRESULT)					)	; // グローバル変数
	////////////////////////////////////////////////////////////////////////////////////
	imagSiz = dsConfig->xsize*dsConfig->ysize				;	
	////////////////////////////////////////////////////////////////////////////////////
	if     ( dsConfig->depth ==  8 ){ // 初期化階調
		sz[j++] = 0											;
		sz[j++] = 0											;
		sz[j++] = MEM_ALN( imagSiz * sizeof(BYTE)		)	; // 画像ﾊﾞｯﾌｧ
	}
	else if( dsConfig->depth == 24 ){ // 初期化階調
		sz[j++] = MEM_ALN( imagSiz * sizeof(RGBZ)		)	; // 画像ﾊﾞｯﾌｧ
		sz[j++] = MEM_ALN( imagSiz * sizeof(BGR3)		)	; // 画像ﾊﾞｯﾌｧ
		sz[j++] = MEM_ALN( imagSiz * sizeof(BYTE)		)	; // 画像ﾊﾞｯﾌｧ
	}
	////////////////////////////////////////////////////////////////////////////////////
	sz[j++] = MEM_ALN( MAXOBJNUM*sizeof(DIOBJECT)		)	; // ｵﾌﾞｼﾞｪｸﾄﾊﾞｯﾌｧ
	sz[j++] = MEM_ALN( dsConfig->ysize * sizeof(LONG)	)	; // 画像処理用
	sz[j++] = MEM_ALN( dsConfig->ysize * sizeof(LONG)	)	; // 画像処理用
	sz[j++] = MEM_ALN( dsConfig->ysize * sizeof(LONG)	)	; // 画像処理用
	sz[j++] = MEM_ALN( dsConfig->ysize * sizeof(POIN)*4	)	; // 画像処理用
	sz[j++] = MEM_ALN( dsConfig->xsize * sizeof(LONG)*2	)	; // 画像処理用
	////////////////////////////////////////////////////////////////////////////////////
	if( InitBlockSize(	dsConfig->xsize,//AREA_WIDMAX/*dsConfig->xsize*/,
						dsConfig->ysize,//AREA_HEIMAX/*dsConfig->ysize*/,
						4,
						4,
						&block					   )!=TRUE ){ // 仮 ﾌﾞﾛｯｸ計算
		return	FALSE ;
	}
	if( InitBlockBuffSiz      ( &sz[j++],0, &block )!=TRUE ){ // 仮 ﾌﾞﾛｯｸ計算
		return	FALSE ;
	}
	if( _INIT_CONNECT_COMP_SIZ( &sz[j++],MAXOBJNUM )!=TRUE ){ // 仮 輪郭追跡
		return	FALSE ;
	}
	////////////////////////////////////////////////////////////////////////////////////
	k      = 0												; // 合計計算
	for( i = 0 ; i < j ; i ++ ) k += sz[ i ]				; // 合計計算
	*worksize = k + _MEMSIZEMARGIN							; // 合計計算
	/*
	printf( "WRK total ===========> EXTERNAL: %6d[KB]\n", k/1024 ) ;
	//*/
	/*
	*worksize = obd_memsize[j] +_MEMSIZEMARGIN				;
	//*/
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Write "E N D" message.
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	#ifdef	_RECOGLOG
	WFP = _FOPEN( _LOG_TEXT, "a" )							;
	if( WFP!=NULL ){
		_FPRINTF( WFP, "DSP_GetWorkSize E N D\n" )			;
		_FCLOSE ( WFP )										;
	}
	#endif//_RECOGLOG
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Return "PSERR_TRUE".
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	return ( ret ) ;
}

/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Initialize system parameters.
//				   オブジェクト認識ライブラリ公開関数(初期化関数)
//--------------------------------------------------------------------------------------
//	Input		 : dsConfig		: 設定パラメータ
//				 : pextBuf		: 占有外部メモリ
//--------------------------------------------------------------------------------------
//	Output		 : -
//--------------------------------------------------------------------------------------
//	Return Value : PSERR_TRUE(0): success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//--------------------------------------------------------------------------------------
//	Date		 : 2020.01.11
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
BOOL DLLEXPORT	DSP_ProcessInit		( DSPConfig	*dsConfig	, // 設定パラメータ
									  BYTE		*pextBuf	) // 占有外部メモリ
{
	GIMG		gtmp, *pg=NULL								; // 警告対策
	CIMG		ctmp, *pc=NULL								; // 警告対策
	BOOL		ret=PSERR_TRUE								;
	BOOL		i, j										;
	BYTE*		pextTmp=pextBuf								; // 外部ﾒﾓﾘ領域
	DIPPARAM*	dipParam									; // パラメータ
	DIRESULT*	diResult									; // 結果構造体

	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Write "START" message.
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	#ifdef	_RECOGLOG
	WFP = _FOPEN( _LOG_TEXT, "a" )							;
	if( WFP!=NULL ){
		_FPRINTF( WFP, "DSP_ProcessInit START\n" )			;
		_FCLOSE ( WFP )										;
	}
	#endif//_RECOGLOG
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Pointer NULL check.
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	if( dsConfig==NULL || pextBuf==NULL ) return PSERR_ARGU ;

	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Check global variable "WORKSIZE" and "INITEXEC" first.
	// DSP_GetWorkSize を実行しなければならない!!
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	#if 0 // これはどうしようもない
	if( WORKSIZE==OFF ){
		return PSERR_PROC			  ;
	}
	if( /*
		INITEXEC==ON                 &&
		//*/
		(orgimgWid!=dsConfig->xsize) ||
		(orgimgHei!=dsConfig->ysize) ){
		/*
		(pextBuf  !=extBuf         ) ){
		//*/
		return PSERR_PROC			  ;
	}
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Check all parameters and argument.
	// 画像ｻｲｽﾞﾁｪｯｸ
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	j = DSPIMG_SIZESET ;
	for( i=0 ; i<DSPIMG_SIZESET ; i++ ){
		if( dsConfig->xsize==DSPIMG_WID[i] && dsConfig->ysize==DSPIMG_HEI[i] ){
			j = i											;
			break											;
		}
	}
	if( j==DSPIMG_SIZESET ){
		return PSERR_IMAG									;
	}
	#endif
	if( dsConfig->depth!=8 && dsConfig->depth!=24 ){
		return PSERR_IMAG									;
	}
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Initialize parameters.
	// 1)ｸﾞﾛｰﾊﾞﾙ変数割り当て
	// 2)ﾊﾟﾗﾒｰﾀ初期化
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	dipParam			= (DIPPARAM*)(pextTmp)								;
	diResult			= (DIRESULT*)(pextTmp + MEM_ALN(sizeof(DIPPARAM)))	;
	pextTmp				= (BYTE*    )(diResult)								;
	pextTmp				= (BYTE*    )(pextTmp + MEM_ALN(sizeof(DIRESULT)))	;
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	dipParam->extbuf    = pextTmp							; // 外部ﾒﾓﾘ先頭ﾎﾟｲﾝﾀを渡す (重要)
	dipParam->intbuf    = NULL								; // 内部ﾒﾓﾘ先頭ﾎﾟｲﾝﾀを渡す (重要)
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	dipParam->initexe   = 0xabcdabcd						; // 初期化ﾌﾗｸﾞ 固定値(保証はできない)
	dipParam->initdep   = dsConfig->depth					; // 初期化階調 (8or24)
	dipParam->origwid   = dsConfig->xsize					; // 原画像横幅
	dipParam->orighei   = dsConfig->ysize					; // 原画像高さ
	dipParam->origsiz   = dsConfig->xsize*dsConfig->ysize	; // 原画像面積
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	dipParam->rect.sx   = 0									; // 一応初期化 処理対象領域(広域)
	dipParam->rect.sy   = 0									; // 一応初期化 処理対象領域(広域)
	dipParam->rect.ex   = dsConfig->xsize-1					; // 一応初期化 処理対象領域(広域)
	dipParam->rect.ey   = dsConfig->ysize-1					; // 一応初期化 処理対象領域(広域)
	dipParam->rectwid	= dsConfig->xsize					; // 一応初期化 処理対象領域(広域)
	dipParam->recthei	= dsConfig->ysize					; // 一応初期化 処理対象領域(広域)
	dipParam->rectsiz	= dsConfig->xsize*dsConfig->ysize	; // 一応初期化 処理対象領域(広域)
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	dipParam->prcmode   = 0x00								; // prcmode INIT初期化
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	if     ( dsConfig->depth ==  8 ){ // 初期化階調
		gtmp.bSize		  = dipParam->origwid>>3			; // 一応初期化
		gtmp.xSize		  = dipParam->origwid				; // 一応初期化
		gtmp.ySize		  = dipParam->orighei				; // 一応初期化
		gtmp.Xdpi		  = 0								; // 一応初期化
		gtmp.Ydpi		  = 0								; // 一応初期化
		gtmp.pgImg		  = NULL							; // 一応初期化
		pg                = &gtmp							; // 一応初期化
		pc				  = NULL							; // 一応初期化
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		dipParam->rcgmode = 0x00							; // rcgmode
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
	}
	else if( dsConfig->depth == 24 ){ // 初期化階調
		ctmp.xSize		  = dipParam->origwid				; // 一応初期化
		ctmp.ySize		  = dipParam->orighei				; // 一応初期化
		ctmp.Xdpi		  = 0								; // 一応初期化
		ctmp.Ydpi		  = 0								; // 一応初期化
		ctmp.pcImg		  = NULL							; // 一応初期化
		pg                = NULL							; // 一応初期化
		pc				  = &ctmp							; // 一応初期化
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		dipParam->rcgmode = 0x0A							; // rcgmode カラーはカラーで処理
		dipParam->rcgmode = 0x01 							; // rcgmode カラーもグレーで処理
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
	}
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// I N I T I A L  P R O C E S S I N G
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	ret                = _RcgNavigator( dipParam, pg, pc, NULL, diResult ) ; // 初期化
	if( ret==FALSE ){
		return PSERR_PROC ;
	}
	///*
	printf( "WRK total ===========> EXTERNAL:%8d[KB]\n", (dipParam->endbuf-pextBuf)/1024 ) ;
	//*/
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Write "E N D" message.
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	#ifdef	_RECOGLOG
	WFP = _FOPEN( _LOG_TEXT, "a" )							;
	if( WFP!=NULL ){
		_FPRINTF( WFP, "DSP_ProcessInit E N D\n" )			;
		_FCLOSE ( WFP )										;
	}
	#endif//_RECOGLOG
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Return "PSERR_TRUE".
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	return ( PSERR_TRUE )									;
}


typedef struct {
	int wid													;
	int hei													;
	int	dat[256*128]										;
	int squ[256*128]										;
} INTEG ;

BOOL DLLEXPORT CalcIntegralPlane	( RCTN		*rect		,
									  GIMG		*zimg		,
									  INTEG		*i_tv		)
{
	BOOL		i, j, k=zimg->xSize, w						;
	BOOL		*i0, *s0									;
	BYTE		*p0, *p1									;
	//memset( zimg->pgImg, 1, 640*240 )						;
	/////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////
	i_tv->wid	= rect->ex-rect->sx+1						;
	i_tv->hei	= rect->ey-rect->sy+1						;
	w			= i_tv->wid									;
	p0			= zimg->pgImg+k*rect->sy+rect->sx			;
	i0			= i_tv->dat									;
	s0			= i_tv->squ									;
	/////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////
	p1			= p0										;
	/////////////////////////////////////////////////////////
	*i0			= (*p1)										;
	*s0			= (*p1)*(*p1)								;
	i0++													;
	s0++													;
	p1++													;
	for( i=1 ; i<w ; i++, i0++, s0++, p1++ ){
		*i0		= *(i0-1) + (*p1)							;
		*s0		= *(s0-1) + (*p1)*(*p1)						;
	}
	/////////////////////////////////////////////////////////
	p0 += k													;
	for( j=1 ; j<i_tv->hei ; j++ ){
		p1		= p0										;
		/////////////////////////////////////////////////////
		*i0		= (*p1)		  +	*(i0-w)						;
		*s0		= (*p1)*(*p1) +	*(s0-w)						;
		i0++												;
		s0++												;
		p1++												;
		for( i=1 ; i<w ; i++, i0++, s0++, p1++ ){
			*i0 = *(i0-1) + (*p1)	    + *(i0-w)-*(i0-w-1)	;
			*s0 = *(s0-1) + (*p1)*(*p1) + *(s0-w)-*(s0-w-1)	;
		}
		/////////////////////////////////////////////////////
		p0 += k												;
	}
	/////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////
	/*k=0;
	for( j=0 ; j<i_tv->hei ; j++ ){
		for( i=0 ; i<w ; i++, k++ ){
			printf( "%5d ", i_tv->dat[k] ) ;
		}
		printf( "\n" ) ;
	}
	k=0;
	for( j=0 ; j<i_tv->hei ; j++ ){
		for( i=0 ; i<w ; i++, k++ ){
			printf( "%5d ", i_tv->squ[k] ) ;
		}
		printf( "\n" ) ;
	}*/
	return ( 1 )											;
}
BOOL DLLEXPORT	SetIntegralPlanes	( RCTN		*rect		,
									  GIMG		*zimg0		,
									  GIMG		*zimg1		,
									  INTEG		*i_tv0		,
									  INTEG		*i_tv1		)
{
	CalcIntegralPlane( rect, zimg0, i_tv0	)				;
	CalcIntegralPlane( rect, zimg1, i_tv1	)				;
	return ( 1 )											;
}
BOOL DLLEXPORT ScanImageIntegPlane	( BOOL		bW			, // block wid
									  BOOL		bH			, // block hei 
									  FLOA		bS			, // block 1/S
									  RCTN		*rect		, // 矩形領域情報
									  ///////////////////////
									  GIMG		*gimg		, // 左:原画像,右:推論画像
									  INTEG		*i_tv		, // 積分画像
									  GIMG		*pimg		, // 左:正解
									  INTEG		*i_pp		, // 積分画像
									  GIMG		*qimg		, // 左:影画
									  INTEG		*i_qq		, // 積分画像
									  ///////////////////////
									  GIMG		*edge		, // 左:エッジ情報
									  FLOA		*pcor		, // 相関値BUF
									  FLOA		*qcor		) // 相関値BUF
{
	BOOL		i, j, I, J, wid, hei, WID, HEI				;
	BOOL		sW, sH, sW_, sH_, bW_=bW-1					;

	FLOA		meav, varv, meap, varp, meaq, varq			;
	
	BOOL		*vd0, *vd1, *vd2, *vd3						;
	BOOL		*vs0, *vs1, *vs2, *vs3						;
	
	BOOL		*pd0, *pd1, *pd2, *pd3						;
	BOOL		*ps0, *ps1, *ps2, *ps3						;

	BOOL		*qd0, *qd1, *qd2, *qd3						;
	BOOL		*qs0, *qs1, *qs2, *qs3						;
	
	BYTE		*g0, *g1, *g2, *p0, *p1, *p2, *q0, *q1, *q2 ;
	BYTE		*e0, *e1									;

	FLOA		COP, COQ, SQV, SQP, SQQ						;
	FLOA		*P0, *P1, *Q0, *Q1							; 
	static FLOA	SMP[64], SMQ[64]							;

	/////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////
	/////////////////////////////////////////////////////////
	if( i_tv->wid!=rect->ex-rect->sx+1 || i_tv->hei!=rect->ey-rect->sy+1 ){
		return ( 0 )										; // ERROR
	}
	wid			= gimg->xSize								; // 画像横幅
	hei			= gimg->ySize								; // 画像高さ
	WID			= i_tv->wid									; // rect wid
	HEI			= i_tv->hei									; // rect hei
	sW			= WID-bW									; // scan wid
	sH			= HEI-bH									; // scan hei
	sW_			= sW-1										; // scan wid-1  	  
	sH_			= sH-1										; // scan hei-1


	g0			= gimg->pgImg+gimg->xSize*(rect->sy+ 1  )+(rect->sx+ 1  ) ; // 画像
	p0			= pimg->pgImg+pimg->xSize*(rect->sy+ 1  )+(rect->sx+ 1  ) ; // 画像
	q0			= qimg->pgImg+qimg->xSize*(rect->sy+ 1  )+(rect->sx+ 1  ) ; // 画像

	e0			= edge->pgImg+edge->xSize*(rect->sy+bH/2)+(rect->sx+bW/2) ; // 画像
	P0			= pcor		 +gimg->xSize*(rect->sy+bH/2)+(rect->sx+bW/2) ; // 相関
	Q0			= qcor		 +gimg->xSize*(rect->sy+bH/2)+(rect->sx+bW/2) ; // 相関
	

	/////////////////////////////////////////////////////////
	vd0			= i_tv->dat									; // 積分dat
	vd1			= i_tv->dat+(bW)							; // 積分dat
	vd2			= i_tv->dat+(bH)*WID+(bW)					; // 積分dat
	vd3			= i_tv->dat+(bH)*WID						; // 積分dat
	/////////////////////////////////////////////////////////
	vs0			= i_tv->squ									; // 積分squ
	vs1			= i_tv->squ+(bW)							; // 積分squ
	vs2			= i_tv->squ+(bH)*WID+(bW)					; // 積分squ
	vs3			= i_tv->squ+(bH)*WID						; // 積分squ
	/////////////////////////////////////////////////////////
	pd0			= i_pp->dat									; // 積分dat
	pd1			= i_pp->dat+(bW)							; // 積分dat
	pd2			= i_pp->dat+(bH)*WID+(bW)					; // 積分dat
	pd3			= i_pp->dat+(bH)*WID						; // 積分dat
	/////////////////////////////////////////////////////////
	ps0			= i_pp->squ									; // 積分squ
	ps1			= i_pp->squ+(bW)							; // 積分squ
	ps2			= i_pp->squ+(bH)*WID+(bW)					; // 積分squ
	ps3			= i_pp->squ+(bH)*WID						; // 積分squ
	/////////////////////////////////////////////////////////
	qd0			= i_qq->dat									; // 積分dat
	qd1			= i_qq->dat+(bW)							; // 積分dat
	qd2			= i_qq->dat+(bH)*WID+(bW)					; // 積分dat
	qd3			= i_qq->dat+(bH)*WID						; // 積分dat
	/////////////////////////////////////////////////////////
	qs0			= i_qq->squ									; // 積分squ
	qs1			= i_qq->squ+(bW)							; // 積分squ
	qs2			= i_qq->squ+(bH)*WID+(bW)					; // 積分squ
	qs3			= i_qq->squ+(bH)*WID						; // 積分squ
	/////////////////////////////////////////////////////////
	memset( SMP, 0, bW*sizeof(FLOA) )						; // RESET
	memset( SMQ, 0, bW*sizeof(FLOA) )						; // RESET

	for( j=0 ; j<sH ; j++ ){

		/////////////////////////////////////////////////////
		/////////////////////////////////////////////////////
		/////////////////////////////////////////////////////
		/////////////////////////////////////////////////////
		meav	= (FLOA)((*vd2+*vd0)-(*vd1+*vd3))*bS			;
		varv	= (FLOA)((*vs2+*vs0)-(*vs1+*vs3))*bS-meav*meav	;
		meap	= (FLOA)((*pd2+*pd0)-(*pd1+*pd3))*bS			;
		varp	= (FLOA)((*ps2+*ps0)-(*ps1+*ps3))*bS-meap*meap	;
		meaq	= (FLOA)((*qd2+*qd0)-(*qd1+*qd3))*bS			;
		varq	= (FLOA)((*qs2+*qs0)-(*qs1+*qs3))*bS-meaq*meaq	;
		/////////////////////////////////////////////////////
		/////////////////////////////////////////////////////
		/////////////////////////////////////////////////////
		/////////////////////////////////////////////////////
		for( I=0 ; I<bW ; I++, g0++, p0++, q0++ ){
			g1	= g0										;
			p1	= p0										;
			q1	= q0										;
			for( J=0 ; J<bH ; J++, g1+=wid, p1+=wid, q1+=wid ){
				SMP[I] += ((FLOA)(*g1)-meav)*((FLOA)(*p1)-meap) ;
				SMQ[I] += ((FLOA)(*g1)-meav)*((FLOA)(*q1)-meaq) ;
			}
		}
		SQV		= (FLOA)sqrt((double)(varv))				;
		SQP		= (FLOA)sqrt((double)(varp))				;
		SQQ		= (FLOA)sqrt((double)(varq))				;
		COP		= bS/(SQV*SQP+0.00000000001)				;
		COQ		= bS/(SQV*SQQ+0.00000000001)				;
		for( I=0 ; I<bW ; I++ ){
			*P0 += SMP[I]									;
			*Q0 += SMQ[I]									;
		}
		*P0		*= COP										;
		*Q0		*= COQ										;
		/*
		for( I=0 ; I<bW ; I++ ){
			SMP[I] = SMP[I+1]								;
			SMQ[I] = SMQ[I+1]								;
		}
		SMP[I] = SMQ[I] = 0.0f								;
		//*/
		memset( SMP, 0, bW*sizeof(FLOA) )					;
		memset( SMQ, 0, bW*sizeof(FLOA) )					;
		/////////////////////////////////////////////////////
		/////////////////////////////////////////////////////
		/////////////////////////////////////////////////////
		/////////////////////////////////////////////////////
		vd0++,vd1++,vd2++,vd3++								;
		vs0++,vs1++,vs2++,vs3++								;
		pd0++,pd1++,pd2++,pd3++								;
		ps0++,ps1++,ps2++,ps3++								;
		qd0++,qd1++,qd2++,qd3++								;
		qs0++,qs1++,qs2++,qs3++								;
		/////////////////////////////////////////////////////
		/////////////////////////////////////////////////////
		/////////////////////////////////////////////////////
		/////////////////////////////////////////////////////
		g0-=bW_, p0-=bW_, q0-=bW_, e0++, P0++, Q0++			;

		for( i=0 ; i<sW_ ; i++ ){

			/////////////////////////////////////////////////
			/////////////////////////////////////////////////
			/////////////////////////////////////////////////
			/////////////////////////////////////////////////
			meav = (FLOA)((*vd2+*vd0)-(*vd1+*vd3))*bS			;
			varv = (FLOA)((*vs2+*vs0)-(*vs1+*vs3))*bS-meav*meav	;
			meap = (FLOA)((*pd2+*pd0)-(*pd1+*pd3))*bS			;
			varp = (FLOA)((*ps2+*ps0)-(*ps1+*ps3))*bS-meap*meap	;
			meaq = (FLOA)((*qd2+*qd0)-(*qd1+*qd3))*bS			;
			varq = (FLOA)((*qs2+*qs0)-(*qs1+*qs3))*bS-meaq*meaq	;
			/////////////////////////////////////////////////
			/////////////////////////////////////////////////
			/////////////////////////////////////////////////
			/////////////////////////////////////////////////
			/*
			g1	= g0										;
			p1	= p0										;
			q1	= q0										;
			for( J=0 ; J<bH ; J++, g1+=wid, p1+=wid, q1+=wid ){
				SMP[bW_] += ((FLOA)(*g1)-meav)*((FLOA)(*p1)-meap) ;
				SMQ[bW_] += ((FLOA)(*g1)-meav)*((FLOA)(*q1)-meaq) ;
			}
			*/
			for( I=0 ; I<bW ; I++, g0++, p0++, q0++ ){
				g1	= g0										;
				p1	= p0										;
				q1	= q0										;
				for( J=0 ; J<bH ; J++, g1+=wid, p1+=wid, q1+=wid ){
					SMP[I] += ((FLOA)(*g1)-meav)*((FLOA)(*p1)-meap) ;
					SMQ[I] += ((FLOA)(*g1)-meav)*((FLOA)(*q1)-meaq) ;
				}
			}
			SQV		= (FLOA)sqrt((double)(varv))			;
			SQP		= (FLOA)sqrt((double)(varp))			;
			SQQ		= (FLOA)sqrt((double)(varq))			;
			COP		= bS/(SQV*SQP+0.00000000001)			;
			COQ		= bS/(SQV*SQQ+0.00000000001)			;
			for( I=0 ; I<bW ; I++ ){
				*P0 += SMP[I]								;
				*Q0 += SMQ[I]								;
			}
			*P0		*= COP									;
			*Q0		*= COQ									;

			if( (*P0>1.01 || *P0<0.991) && *P0!=0.0f ){
				printf( "ERROR\n" ) ;
			}
			/*
			for( I=0 ; I<bW_ ; I++ ){
				SMP[I] = SMP[I+1]							;
				SMQ[I] = SMQ[I+1]							;
			}
			SMP[I] = SMQ[I] = 0.0f							;
			//*/
			memset( SMP, 0, bW*sizeof(FLOA) )				;
			memset( SMQ, 0, bW*sizeof(FLOA) )				;
			/////////////////////////////////////////////////
			/////////////////////////////////////////////////
			/////////////////////////////////////////////////
			/////////////////////////////////////////////////
			vd0++,vd1++,vd2++,vd3++							;
			vs0++,vs1++,vs2++,vs3++							;
			pd0++,pd1++,pd2++,pd3++							;
			ps0++,ps1++,ps2++,ps3++							;
			qd0++,qd1++,qd2++,qd3++							;
			qs0++,qs1++,qs2++,qs3++							;
			/////////////////////////////////////////////////
			/////////////////////////////////////////////////
			/////////////////////////////////////////////////
			/////////////////////////////////////////////////
			g0-=bW_, p0-=bW_, q0-=bW_, e0++, P0++, Q0++		;

		}
		///*
		vd0+=bW,vd1+=bW,vd2+=bW,vd3+=bW						;
		vs0+=bW,vs1+=bW,vs2+=bW,vs3+=bW						;
		pd0+=bW,pd1+=bW,pd2+=bW,pd3+=bW						;
		ps0+=bW,ps1+=bW,ps2+=bW,ps3+=bW						;
		qd0+=bW,qd1+=bW,qd2+=bW,qd3+=bW						;
		qs0+=bW,qs1+=bW,qs2+=bW,qs3+=bW						;
		//*/
		g0+=bW, p0+=bW, q0+=bW, e0+=bW, P0+=bW, Q0+=bW;

	}


	return ( 1 )											;
}
/*@#$///////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------
//	Purpose		 : Main processing of the Object Recognition.
//				   オブジェクト認識ライブラリ公開関数(メイン関数)
//--------------------------------------------------------------------------------------
//	Input		 : dsConfig		: 設定パラメータ
//				 : pextBuf		: 占有外部メモリ
//				 : psGimg		: グレー画像データ
//				 : psCimg		: カラー画像データ
//--------------------------------------------------------------------------------------
//	Output		 : dsResult		: 認識結果データ
//--------------------------------------------------------------------------------------
//	Return Value : PSERR_TRUE(0): success
//				   error number : otherwise
//				   (returns TRUE on success, an error number on failure)
//               : PSERR_PROC, PSERR_ARGU, PSERR_IMAG, (PSERR_CERT)
//--------------------------------------------------------------------------------------
//	Date		 : 2020.01.11
//--------------------------------------------------------------------------------------
//	Modified	 : ****.**.**
//--------------------------------------------------------------------------------------
///////////////////////////////////////////////////////////////////////////////////@#$*/
BOOL DLLEXPORT	DSP_ProcessExec		( DSPConfig	*dsConfig	, // 設定パラメータ
									  BYTE		*pextBuf	, // 占有外部メモリ
									  PSGimg	*psGimg	    , // 入力原画像グレー
									  PSCimg	*psCimg		, // 入力原画像カラー
									  DSPResult	*dsResult	) // 結果構造体
{
	BOOL		i, j										;
	LONG		ww0, ww1, hh0, hh1							;
	BOOL		ret   =PSERR_TRUE							;
	CIMG		cimg, *pcimg=NULL							;
	GIMG		gimg, *pgimg=NULL							;
	BYTE*		pextTmp=pextBuf								; // 外部ﾒﾓﾘ領域
	DIPPARAM*	dipParam									; // パラメータ
	DIRESULT*	diResult									; // 結果構造体
	////////////////////////////////////////////////////////////////////////////////////
	GIMG		zimg0, zimg1, zimg2							;
	IMGI		imgInfo										;
	RGBQ		rgbq[256]									;
	static BYTE	pgz0[640*240], pgz1[640*240], pgz2[640*240]	;
	static FLOA	cor0[640*240], cor1[640*240]				; // 相関平面
	zimg0.depth = zimg1.depth = zimg2.depth = 256			;
	zimg0.xSize = zimg1.xSize = zimg2.xSize = 640			;
	zimg0.ySize = zimg1.ySize = zimg2.ySize = 240			;
	zimg0.pgImg = pgz0,zimg1.pgImg = pgz1,zimg2.pgImg = pgz2;
	static char str0[]  = "./ZIP010.bmp"					; // 正解
	static char str1[]  = "./ZIP011.bmp"					; // 影画
	static char str2[]  = "./ZIP012.bmp"					; // EDGE
	_CHECK_BMPFILE( str0, &imgInfo )						;
	_LOAD_BMPDATA ( str0, &imgInfo, rgbq, NULL, &zimg0, NULL ) ;
	_LOAD_BMPDATA ( str1, &imgInfo, rgbq, NULL, &zimg1, NULL ) ;
	_LOAD_BMPDATA ( str2, &imgInfo, rgbq, NULL, &zimg2, NULL ) ;
	INTEG		i_nhk0, i_nhk1, i_tvtv						;
	static RCTN	r_nhk	= { 124, 64, 219, 127 }				;
	BOOL		bW0=2,bH0=2									;
	FLOA		bS0=1.0f/(FLOA)(bW0*bH0)					;
	//i_nhk0.wid = r_nhk.ex-r_nhk.sx+1						;
	//i_nhk0.hei = r_nhk.ey-r_nhk.sy+1						;
	//ret = SetIntegralPlanes( &r_nhk, &zimg0, &zimg1, &i_nhk0, &i_nhk1 ) ;
	ret = CalcIntegralPlane( &r_nhk, &zimg0, &i_nhk0 )		; // 事前準備
	ret = CalcIntegralPlane( &r_nhk, &zimg1, &i_nhk1 )		; // 事前準備
	memset( cor0, 0, sizeof(cor0) )							; // RESET
	memset( cor1, 0, sizeof(cor1) )							; // RESET
	////////////////////////////////////////////////////////////////////////////////////

	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Write "START" message.
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	#ifdef	_RECOGLOG
	WFP = _FOPEN( _LOG_TEXT, "a" )							;
	if( WFP!=NULL ){
		_FPRINTF( WFP, "DSP_ProcessExec START\n" )			;
		_FCLOSE ( WFP )										;
	}
	#endif//_RECOGLOG
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Pointer NULL check.
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	if( dsConfig==NULL || ( psGimg==NULL && psCimg==NULL ) || dsResult==NULL ){
		return PSERR_ARGU									;
	}
	if( ( psGimg==NULL && psCimg->pcImg==NULL ) ||
		( psCimg==NULL && psGimg->pgImg==NULL ) ){
		return PSERR_ARGU									;
	}
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Check and reset global variable.
	// 1)ｸﾞﾛｰﾊﾞﾙ変数割り当て
	// 2)ﾊﾟﾗﾒｰﾀﾁｪｯｸ・初期化
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	dipParam			= (DIPPARAM*)(pextTmp)				;
	pextTmp				= (BYTE*    )(dipParam)				;
	diResult			= (DIRESULT*)(pextTmp+MEM_ALN(sizeof(DIPPARAM))) ;
	pextTmp				= (BYTE*    )(diResult)				;
	pextTmp				= (BYTE*    )(pextTmp+MEM_ALN(sizeof(diResult))) ;
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	if( dipParam->initexe!=0xabcdabcd ){
		return PSERR_PROC									; // 初期化ﾌﾗｸﾞﾁｪｯｸ
	}
	if( dipParam->initdep!=dsConfig->depth ){
		return PSERR_IMAG									; // 初期化階調ﾁｪｯｸ
	}
	if( dipParam->origwid!=dsConfig->xsize ){
		return PSERR_IMAG									; // 画像ｻｲｽﾞﾁｪｯｸ
	}
	if( dipParam->orighei!=dsConfig->ysize ){
		return PSERR_IMAG									; // 画像ｻｲｽﾞﾁｪｯｸ
	}
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////

	memcpy( &dipParam->squr[0], &dsConfig->dsarea[0], sizeof(SQUR) ) ; // パーツ結果4点
	dipParam->area[0].sx = dsConfig->fpoint[0].x ; // 正解情報(仮)
	dipParam->area[0].sy = dsConfig->fpoint[0].y ; // 正解情報(仮)
	dipParam->area[0].ex = dsConfig->fpoint[1].x ; // 正解情報(仮)
	dipParam->area[0].ey = dsConfig->fpoint[1].y ; // 正解情報(仮)

	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// 処理対象矩形領域ﾁｪｯｸ
	if( (dsConfig->dsrect.sx!=0) || (dsConfig->dsrect.ex!=(dsConfig->xsize-1)) ) return PSERR_ARGU ;
	if( (dsConfig->dsrect.sy!=0) || (dsConfig->dsrect.ey!=(dsConfig->ysize-1)) ) return PSERR_ARGU ;
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Create image data "gimg".
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	if     ( psGimg!=NULL ){
		gimg.xSize        = 
		gimg.bSize        = psGimg->xSize					;
		gimg.ySize        = psGimg->ySize					;
		gimg.depth        = 256								;
		gimg.Xdpi         = gimg.Ydpi  = 0					;
		gimg.pgImg        = (BYTE*)psGimg->pgImg			;
		pgimg             = &gimg							;
		pcimg             = NULL							; // 0ﾘｾｯﾄ
		cimg.xSize        = cimg.ySize = 0					; // 0ﾘｾｯﾄ
		cimg.Xdpi         = cimg.Ydpi  = 0					; // 0ﾘｾｯﾄ
		cimg.pcImg        = NULL							; // 0ﾘｾｯﾄ
		if( dipParam->origwid!=psGimg->xSize ){
			return PSERR_IMAG								; // 画像ｻｲｽﾞﾁｪｯｸ
		}
		if( dipParam->orighei!=psGimg->ySize ){
			return PSERR_IMAG								; // 画像ｻｲｽﾞﾁｪｯｸ
		}
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		// dipParam->rcgmode = 0x00							; // rcgmode
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode

		//_SAVE_BMPDATA( "chckX.bmp", (RGBQ*)rgbqGray, NULL, &gimg , NULL ) ; // Inputimage
		//_SAVE_BMPDATA( "chck0.bmp", (RGBQ*)rgbqGray, NULL, &zimg0, NULL ) ; // ZIP010.bmp
		//_SAVE_BMPDATA( "chck1.bmp", (RGBQ*)rgbqGray, NULL, &zimg1, NULL ) ; // ZIP011.bmp
		//_SAVE_BMPDATA( "chck2.bmp", (RGBQ*)rgbqGray, NULL, &zimg2, NULL ) ; // ZIP012.bmp


		//memset( gimg.pgImg, 1, sizeof(pgz0) )				;


		ret = CalcIntegralPlane( &r_nhk, &gimg, &i_tvtv )	; // integ計算

		

		// 準備できたもの
		// i_tvtv
		// i_nhk0
		// i_nhk1
		// gimg  orgimg
		// zimg0 normal
		// zimg1 shadow
		// zimg2 lgedge

		// 入力
		// r_nhk,gimg,i_tvtv,zimg0,i_nhk0,zimg1,i_nhk1,zimg2


		ret = ScanImageIntegPlane( bW0, bH0, bS0, &r_nhk, &gimg, &i_tvtv, &gimg , &i_tvtv, &zimg1, &i_nhk1, &zimg2, cor0, cor1 ) ;

		ret = ScanImageIntegPlane( 16,8,7, &r_nhk, &gimg, &i_tvtv, &zimg0, &i_nhk0, &zimg1, &i_nhk1, &zimg2, cor0, cor1 ) ;



		// 出力











	}
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Create image data "cimg".
	// BGR24BITの場合、落ちる => この時点では Corg が
	// BGRZ BGRZ BGRZ にはなっていない BGR BGR BGR になっている
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	else if( psCimg!=NULL ){
		cimg.xSize        = psCimg->xSize                   ;
		cimg.ySize        = psCimg->ySize                   ;
		cimg.Xdpi         = 0                               ;
		cimg.Ydpi         = 0                               ;
		cimg.pcImg        = (BGR3*)psCimg->pcImg            ; // 仮 _ExecProcSub0(_dsp_exec_recog.c)で変換
		pcimg             = &cimg							;
		pgimg             = NULL							; // 0ﾘｾｯﾄ
		gimg.xSize        = gimg.ySize = 0					; // 0ﾘｾｯﾄ
		gimg.Xdpi         = gimg.Ydpi  = 0					; // 0ﾘｾｯﾄ
		gimg.depth        = 0								; // 0ﾘｾｯﾄ
		gimg.pgImg        = NULL							; // 0ﾘｾｯﾄ
		if( dipParam->origwid!=psCimg->xSize ){
			return PSERR_IMAG								; // 画像ｻｲｽﾞﾁｪｯｸ
		}
		if( dipParam->orighei!=psCimg->ySize ){
			return PSERR_IMAG								; // 画像ｻｲｽﾞﾁｪｯｸ
		}
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		// dipParam->rcgmode = 0x0A							; // rcgmode
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
		// rcgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmodercgmode
	}
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Initialize variables.
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	dipParam->prcmode     = 0xff									; // prcmode EXEC実行
	memcpy( &(dipParam->rect), &(dsConfig->dsrect), sizeof(RCTN) )	; // 矩形領域ｺﾋﾟｰ
	dipParam->rectwid     = dipParam->rect.ex-dipParam->rect.sx+1	; // 矩形領域ｺﾋﾟｰ
	dipParam->recthei     = dipParam->rect.ey-dipParam->rect.sy+1	; // 矩形領域ｺﾋﾟｰ
	dipParam->rectsiz     = dipParam->rectwid*dipParam->recthei		; // 矩形領域ｺﾋﾟｰ
	if( dipParam->rectwid < DIPIMG_RECTSIZEMIN ||
		dipParam->recthei < DIPIMG_RECTSIZEMIN ){
		return PSERR_PROC									;
	}
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// dsResult 初期化
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	diResult->objNum      =  0                              ;
	dsResult->reserve0    = -1                              ;
	dsResult->reserve1    = -1                              ;
	for( i=0 ; i<(LONG)DSPRCG_OBJMAX ; i++ ){
		diResult->id  [i] =
		dsResult->id  [i] = 9999							;
		//diResult->sjis[i] =
		//dsResult->sjis[i] = 0x8196/*＊*/					;
	}


















	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// M A I N  P R O C E S S
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	if     ( psCimg!=NULL ){
		if( dsConfig->recognum>DSPRCG_OBJMAX ){
			return PSERR_ARGU ;
		}
#if 0
		dipParam->recognum = dsConfig->recognum				;
 		for( i=0 ; i<dipParam->recognum ; i++ ){
			// 領域ｺﾋﾟｰ(狭域)
			dipParam->squr   [i].P0.x = dsConfig->dsarea[i].P0.x ;
			dipParam->squr   [i].P0.y = dsConfig->dsarea[i].P0.y ;
			dipParam->squr   [i].P1.x = dsConfig->dsarea[i].P1.x ;
			dipParam->squr   [i].P1.y = dsConfig->dsarea[i].P1.y ;
			dipParam->squr   [i].P2.x = dsConfig->dsarea[i].P2.x ;
			dipParam->squr   [i].P2.y = dsConfig->dsarea[i].P2.y ;
			dipParam->squr   [i].P3.x = dsConfig->dsarea[i].P3.x ;
			dipParam->squr   [i].P3.y = dsConfig->dsarea[i].P3.y ;
			// 位置ﾁｪｯｸ
			if( dipParam->squr[i].P0.x<0 || dipParam->squr[i].P0.x>=psCimg->xSize ||
				dipParam->squr[i].P0.y<0 || dipParam->squr[i].P0.y>=psCimg->ySize ||
				dipParam->squr[i].P1.x<0 || dipParam->squr[i].P1.x>=psCimg->xSize ||
				dipParam->squr[i].P1.y<0 || dipParam->squr[i].P1.y>=psCimg->ySize ||
				dipParam->squr[i].P2.x<0 || dipParam->squr[i].P2.x>=psCimg->xSize ||
				dipParam->squr[i].P2.y<0 || dipParam->squr[i].P2.y>=psCimg->ySize ||
				dipParam->squr[i].P3.x<0 || dipParam->squr[i].P3.x>=psCimg->xSize ||
				dipParam->squr[i].P3.y<0 || dipParam->squr[i].P3.y>=psCimg->ySize ){
				return PSERR_ARGU							;
			}
			// 位置関係ﾁｪｯｸ
			if( dipParam->squr[i].P0.x>=dipParam->squr[i].P1.x ||
				dipParam->squr[i].P3.x>=dipParam->squr[i].P2.x ||
				dipParam->squr[i].P0.y>=dipParam->squr[i].P3.y ||
				dipParam->squr[i].P1.y>=dipParam->squr[i].P2.y ){
				return PSERR_ARGU							;
			}
			// 四角領域
			// P0~P1,P3~P2距離を求める
			_GET_PAIR_DSTDIR( &dipParam->squr[i].P0, &dipParam->squr[i].P1, &ww0, (LONG*)&j ) ;
			_GET_PAIR_DSTDIR( &dipParam->squr[i].P3, &dipParam->squr[i].P2, &ww1, (LONG*)&j ) ;
			// P0~P3,P1~P2距離を求める
			_GET_PAIR_DSTDIR( &dipParam->squr[i].P0, &dipParam->squr[i].P3, &hh0, (LONG*)&j ) ;
			_GET_PAIR_DSTDIR( &dipParam->squr[i].P1, &dipParam->squr[i].P2, &hh1, (LONG*)&j ) ;
			dipParam->areawid[i] = (ww0+ww1)>>1				;
			dipParam->areahei[i] = (hh0+hh1)>>1				;
			//dipParam->areawid[i]    = dipParam->area[i].ex-dipParam->area[i].sx+1 ;
			//dipParam->areahei[i]    = dipParam->area[i].ey-dipParam->area[i].sy+1 ;
		
			// 必ず9以上x11以上
			if( dipParam->areawid[i]<9 || dipParam->areahei[i]<11 ){
				return PSERR_ARGU							;
			}
			if( dipParam->areahei[i]>   3*dipParam->areawid[i]    ){ // areahei>3*areawid はｴﾗｰ....
				return PSERR_ARGU							;
			}
			dipParam->areasiz[i] = dipParam->areawid[i]*dipParam->areahei[i] ;
	
			// 処理文字ｻｲｽﾞ
			// これには比率で入れてもらう
			// 38,64 など....
			// charhei>3*charwid はｴﾗｰ....
			// 64/3 = 22 以上
			// 必ず22以上!!!!

			dipParam->charwid[i] = dsConfig->charwid[i]		;
			dipParam->charhei[i] = dsConfig->charhei[i]		;

			//if( dipParam->charwid[i]<OCCHR_WIDMIN/*5*/ || dipParam->charhei[i]<OCCHR_HEIMIN/*10*/ ){ // 5以上 10以上..... に変更必要か...
			//	return PSERR_ARGU							;
			//}
			if( dipParam->charhei[i]!=64 ){
				return PSERR_ARGU							;
			}
			if( dipParam->charhei[i]/*64固定*/> 3*dipParam->charwid[i] ){ // charhei>3*charwid はｴﾗｰ....
				return PSERR_ARGU							;
			}
			dipParam->charsiz[i] = dipParam->charwid[i]*dipParam->charhei[i] ;

			// areawid,areahei,charwid,charheiのﾁｪｯｸ
			//if( dipParam->areawid[i]<dipParam->charwid[i] || dipParam->areahei[i]<dipParam->charhei[i] ){
			//	return PSERR_ARGU							;
			//}
			// 1次射影画像ｻｲｽﾞ
			//dipParam->normwid[i] = (OCRIMG_WID0/*32*/*dipParam->areawid[i]+(dipParam->charwid[i]>>1)) / dipParam->charwid[i] ; // 0でないことを保証できている
			//dipParam->normhei[i] = (OCRIMG_HEI0/*64*/*dipParam->areahei[i]+(dipParam->charhei[i]>>1)) / dipParam->charhei[i] ; // 0でないことを保証できている
			dipParam->normwid[i] = 64 ; // 固定
			dipParam->normhei[i] = (64*dipParam->areahei[i]+(dipParam->areawid[i]>>1)) / dipParam->areawid[i] ; // 0でないことを保証できている
		
			// これが4の倍数であることが好ましいが.... areawid-1,-2,-3 で4の倍数になるかﾁｪｯｸ?? いや無理
			if( dipParam->normwid[i]> AREA_WIDMAX || dipParam->normhei[i]> AREA_HEIMAX ){
				return PSERR_ARGU							;
			}
			dipParam->normsiz[i] = dipParam->normwid[i]*dipParam->normhei[i] ;

		}
		dipParam->scanstp = dsConfig->scanstep				;
		if( dipParam->scanstp< 1 || dipParam->scanstp> 2 ){ // 1,2 のみOK
			return PSERR_ARGU								;
		}
#endif
		ret = _RcgNavigator( dipParam, NULL, &cimg, NULL, diResult ) ; // 実  行
	}
	else if( psGimg!=NULL ){ // カラー
		dipParam->fnumbs  = dsConfig->fnumbs				;
		dipParam->imgbuf  = dsResult->imgbuf				;
		dipParam->dspmode = dsConfig->dsmode				;
		if     ( dipParam->dspmode< 20 ){ // 動作ﾓｰﾄﾞ  0~19	: 学習画像生成
			memcpy( dipParam->fpoint, dsConfig->fpoint, (dsConfig->fnumbs  )*sizeof(POIN) ) ;
		}
		else if( dipParam->dspmode< 30 ){ // 動作ﾓｰﾄﾞ 20~24	: 特徴点逆変換
			memcpy( dipParam->fpoint, dsConfig->fpoint, (dsConfig->fnumbs+4)*sizeof(POIN) ) ;
		}
		else if( dipParam->dspmode==30 ){ // 動作ﾓｰﾄﾞ 30		: Local Normalization
			dipParam->rcgmode = 0x01						; // rcgmode変更!
		}
		ret = _RcgNavigator( dipParam, &gimg, NULL, NULL, diResult ) ; // 実  行
	}

	#ifndef	RELEASEX
	if( dipParam->rcgflag0==3 ) memcpy( (BYTE*)(psCimg->pcImg), dipParam->gcut2.pgImg, cimg.xSize*cimg.ySize ) ;
	else                        memcpy( (BYTE*)(psCimg->pcImg), dipParam->gcut1.pgImg, cimg.xSize*cimg.ySize ) ;
	#endif//RELEASEX
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	//
	// 認 識 結 果 処 理
	// ﾄﾗｯｷﾝｸﾞ,ｼﾞｪｽﾁｬｰ認識,検出結果出力
	// 入力: OBJECT,OBJNUM,frmlog,diResult,diobject
	// 出力: dsResult
	//
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	if( ret== TRUE ){ // 成功
		ret = PSERR_TRUE/* 0*/								;
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		for( i=0 ; i<4 ; i++ ){
			memcpy( &dsResult->obrect[i], &diResult->object[i].rect, sizeof(RCTN) ) ;
		}
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		////////////////////////////////////////////////////////////////////////////////
		/*
		for( i=0 ; i<dipParam->recognum ; i++ ){
			dsResult->id  [i] = diResult->id  [i]			;
			dsResult->sjis[i] = diResult->sjis[i]			;
		}
		//*/
	}
	else            { // 失敗
		ret = PSERR_RECG/*-5*/								;
	}

	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// Write "E N D" message.
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	#ifdef	_RECOGLOG
	WFP = _FOPEN( _LOG_TEXT, "a" )							;
	if( WFP!=NULL ){
		_FPRINTF( WFP, "DSP_ProcessExec E N D\n" )			;
		_FCLOSE ( WFP )										;
	}
	#endif//_RECOGLOG
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	// ｶｳﾝﾄ変数更新,ﾘｾｯﾄ,Return ( ret ).
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	////////////////////////////////////////////////////////////////////////////////////
	dipParam->frmcount ++									;
	dipParam->frmcount = (LONG)( ((dipParam->frmcount-LOGFRMNUM/*8*/)>>31) & dipParam->frmcount ) ;
	return ( ret )											;
}

/*//////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
//	オ ブ ジ ェ ク ト 認 識 ラ イ ブ ラ リ 専 用 コ ー ド - end -
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////*/

/*	End of File //////////////////////////////////////////////////////////////////////*/
